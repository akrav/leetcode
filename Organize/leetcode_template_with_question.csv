number,title,difficulty,tags,question,code
,Contains Duplicate,Easy,Array & Hashing,"Contains Duplicate
Solved 
Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.

Example 1:

Input: nums = [1, 2, 3, 3]

Output: true

Example 2:

Input: nums = [1, 2, 3, 4]

Output: false","class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        dic = defaultdict(int)

        for num in nums:
            dic[num] += 1
            if dic[num] > 1:
                return True
        return False"
,Valid Anagram   ,Easy,Array & Hashing,"Valid Anagram
Solved 
Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: s = ""racecar"", t = ""carrace""

Output: true
Example 2:

Input: s = ""jar"", t = ""jam""

Output: false
Constraints:

s and t consist of lowercase English letters.","# class Solution:
#     def isAnagram(self, s: str, t: str) -> bool:
#         s_dic = defaultdict(int)

#         for letter in s:
#             s_dic[letter] += 1
        
#         for letter in t:
#             s_dic[letter] -= 1
#             if s_dic[letter] < 0:
#                 return False
        
#         for letter in s:
#             if s_dic[letter] != 0:
#                 return False
#         return True

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        s_dic = defaultdict(int)
        t_dic = defaultdict(int)

        if len(s) != len(t):
            return False
        
        for i in range(len(s)):
            s_dic[s[i]] += 1
            t_dic[t[i]] += 1
        
        for letter in s:
            if s_dic[letter] != t_dic[letter]:
                return False
        return True
        "
,Two Sum,Easy,Array & Hashing,"Two Sum
Solved 
Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.

You may assume that every input has exactly one pair of indices i and j that satisfy the condition.

Return the answer with the smaller index first.

Example 1:

Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
Explanation: nums[0] + nums[1] == 7, so we return [0, 1].

Example 2:

Input: nums = [4,5,6], target = 10

Output: [0,2]
Example 3:

Input: nums = [5,5], target = 10

Output: [0,1]
Constraints:

2 <= nums.length <= 1000
-10,000,000 <= nums[i] <= 10,000,000
-10,000,000 <= target <= 10,000,000","# class Solution:
#     def twoSum(self, nums: List[int], target: int) -> List[int]:

#         left = 0
#         right = len(nums) - 1

#         while left < right:
#             l = nums[left]
#             r = nums[right]
#             if l + r == target:
#                 return [left,right]
#             elif l + r < target:
#                 l += 1
#             else:
#                 r -= 1
#         return [-1,-1]

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = defaultdict(lambda: -1)

        for i in range(len(nums)):
            new_target = target - nums[i]
            if dic[new_target] != -1:
                return [dic[new_target], i]
            dic[nums[i]] = i
        return [-1,-1]"
,Longest Common Prefix,Easy,Array & Hashing,"Longest Common Prefix
You are given an array of strings strs. Return the longest common prefix of all the strings.

If there is no longest common prefix, return an empty string """".

Example 1:

Input: strs = [""bat"",""bag"",""bank"",""band""]

Output: ""ba""
Example 2:

Input: strs = [""dance"",""dag"",""danger"",""damage""]

Output: ""da""
Example 3:

Input: strs = [""neet"",""feet""]

Output: """"",
,Group Anagrams,Medium,Array & Hashing,"Group Anagrams
Solved 
Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: strs = [""act"",""pots"",""tops"",""cat"",""stop"",""hat""]

Output: [[""hat""],[""act"", ""cat""],[""stop"", ""pots"", ""tops""]]
Example 2:

Input: strs = [""x""]

Output: [[""x""]]
Example 3:

Input: strs = [""""]

Output: [[""""]]
Constraints:

1 <= strs.length <= 1000.
0 <= strs[i].length <= 100
strs[i] is made up of lowercase English letters.","# class Solution:
#     def groupAnagrams(self, strs: List[str]) -> List[List[str]]:

#         def is_anagram(s, t):
#             s_dic = defaultdict(int)
#             t_dic = defaultdict(int)

#             if len(s) != len(t):
#                 return False

#             for i in range(len(s)):
#                 s_dic[s[i]] += 1
#                 t_dic[t[i]] += 1
            
#             for letter in s:
#                 if s_dic[letter] != t_dic[letter]:
#                     return False

#             return True
        
#         res = [[strs[0]]]
#         for i in range(1, len(strs)):
#             for group in res:
#                 # print(f""group: {group}, strs: {strs[i]}"")
#                 if is_anagram(group[0], strs[i]):
#                     group.append(strs[i])
#                 else:
#                     res.append([strs[i]])
#                     i += 1

#         return res

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for s in strs:
            sortedS = ''.join(sorted(s))
            res[sortedS].append(s)
        return list(res.values())

        "
,Remove Element,Easy,Array & Hashing,"Remove Element
You are given an integer array nums and an integer val. Your task is to remove all occurrences of val from nums in-place.

After removing all occurrences of val, return the number of remaining elements, say k, such that the first k elements of nums do not contain val.

Note:

The order of the elements which are not equal to val does not matter.
It is not necessary to consider elements beyond the first k positions of the array.
To be accepted, the first k elements of nums must contain only elements not equal to val.
Return k as the final result.

Example 1:

Input: nums = [1,1,2,3,4], val = 1

Output: [2,3,4]
Explanation: You should return k = 3 as we have 3 elements which are not equal to val = 1.

Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2

Output: [0,1,3,0,4]
Explanation: You should return k = 5 as we have 5 elements which are not equal to val = 2.

Constraints:

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100",
,Top K Frequent Elements,Medium,Array & Hashing,"Top K Frequent Elements
Solved 
Given an integer array nums and an integer k, return the k most frequent elements within the array.

The test cases are generated such that the answer is always unique.

You may return the output in any order.

Example 1:

Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
Example 2:

Input: nums = [7,7], k = 1

Output: [7]
Constraints:

1 <= nums.length <= 10^4.
-1000 <= nums[i] <= 1000
1 <= k <= number of distinct elements in nums.","class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = defaultdict(int)
        for num in nums:
            dic[num] += 1
        res = []
        for key, value in sorted(dic.items(), key=lambda item: item[1], reverse=True):
            if len(res) == k:
                return res
            res.append(key)
        return res"
,Encode and Decode Strings,Medium,Array & Hashing,"Encode and Decode Strings
Solved 
Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement encode and decode

Example 1:

Input: [""neet"",""code"",""love"",""you""]

Output:[""neet"",""code"",""love"",""you""]
Example 2:

Input: [""we"",""say"","":"",""yes""]

Output: [""we"",""say"","":"",""yes""]
Constraints:

0 <= strs.length < 100
0 <= strs[i].length < 200
strs[i] contains only UTF-8 characters.","class Solution:

    def encode(self, strs: List[str]) -> str:
        ans = """"
        for word in strs:
            ans += f""{len(word)}""+""#""+word
        print(f""encode: {ans}"")
        return ans
    # ""4#neet4#code4#love3#you""
    #  0123456789
    #  [2:6]

    def decode(self, s: str) -> List[str]:
        count = """"
        ans = []

        i = 0
        while i < len(s):
            print(f""s[i]: {s[i]}"")
            if s[i] == ""#"":
                print(f""count: {count}"")
                num_count = int(count)
                print(f""s[i+1: i+1+num_count]: {s[i+1: i+1+num_count]}"")
                ans.append(s[i+1: i+1+num_count])
                i = i+num_count+1
                count = """"
            else:
                count += s[i]
                i += 1

        return ans"
,Products of Array Except Self,Medium,Array & Hashing,"Products of Array Except Self
Solved 
Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].

Each product is guaranteed to fit in a 32-bit integer.

Follow-up: Could you solve it in 
O
(
n
)
O(n) time without using the division operation?

Example 1:

Input: nums = [1,2,4,6]

Output: [48,24,12,8]
Example 2:

Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
Constraints:

2 <= nums.length <= 1000
-20 <= nums[i] <= 20","class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        if len(nums) == 1:
            return nums

        fowards = [nums[0]]
        backwards = [nums[-1]]

        for i in range(1, len(nums)):
            fowards.append(fowards[i-1] * nums[i])
        j = 0 
        for i in range(len(nums)-2, -1, -1 ):
            backwards.append(backwards[j] * nums[i])
            j+=1
        backwards = backwards[::-1]

        ans = []
        for i in range(len(nums)):
            if i == 0:
                ans.append(backwards[i+1])
            elif i == len(nums) - 1:
                ans.append(fowards[i-1])
            else:
                ans.append(fowards[i-1] * backwards[i+1])
        return ans"
,Valid Sudoku,Medium,Array & Hashing,"Valid Sudoku
Solved 
You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:

Each row must contain the digits 1-9 without duplicates.
Each column must contain the digits 1-9 without duplicates.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.
Return true if the Sudoku board is valid, otherwise return false

Note: A board does not need to be full or be solvable to be valid.

Example 1:



Input: board = 
[[""1"",""2"",""."",""."",""3"",""."",""."",""."","".""],
 [""4"",""."",""."",""5"",""."",""."",""."",""."","".""],
 [""."",""9"",""8"",""."",""."",""."",""."",""."",""3""],
 [""5"",""."",""."",""."",""6"",""."",""."",""."",""4""],
 [""."",""."",""."",""8"",""."",""3"",""."",""."",""5""],
 [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
 [""."",""."",""."",""."",""."",""."",""2"",""."","".""],
 [""."",""."",""."",""4"",""1"",""9"",""."",""."",""8""],
 [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]

Output: true
Example 2:

Input: board = 
[[""1"",""2"",""."",""."",""3"",""."",""."",""."","".""],
 [""4"",""."",""."",""5"",""."",""."",""."",""."","".""],
 [""."",""9"",""1"",""."",""."",""."",""."",""."",""3""],
 [""5"",""."",""."",""."",""6"",""."",""."",""."",""4""],
 [""."",""."",""."",""8"",""."",""3"",""."",""."",""5""],
 [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
 [""."",""."",""."",""."",""."",""."",""2"",""."","".""],
 [""."",""."",""."",""4"",""1"",""9"",""."",""."",""8""],
 [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]

Output: false","class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        
        def is_three_by_three_valid(n, m):
            row = n//3 * 3
            col = m//3 * 3
            check = defaultdict(bool)
            for i in range(row, row + 3):
                for j in range(col, col + 3):
                    if board[i][j] == '.':
                        continue
                    if check[board[i][j]]:
                        return False
                    check[board[i][j]] =True
            return True
        
        def is_row_valid(n, m):
            #n is row so we move across using m
            check = defaultdict(bool)
            for j in range(len(board[0])):
                if board[n][j] == '.':
                    continue
                if check[board[n][j]]:
                    return False
                check[board[n][j]] = True
            return True
        
        def is_col_valid(n, m):
            #n is row so we move across using m
            check = defaultdict(bool)
            for i in range(len(board)):
                if board[i][m] == '.':
                    continue
                if check[board[i][m]]:
                    return False
                check[board[i][m]] = True
            return True
        
        check = defaultdict(bool)
        for i in range(len(board)):
            for j in range(len(board[0])):
                box_check = True
                row_check = True
                col_check = True
                n = i//3
                m = j//3
                if check[f""{n},{m}""] == False:
                    box_check = is_three_by_three_valid(i, j)
                    check[f""{n},{m}""] = True
                row_check = is_row_valid(i, j)
                col_check = is_col_valid(i, j)

                if (box_check and row_check and col_check) == False:
                    return False
        return True
"
,Longest Consecutive Sequence,Medium,Array & Hashing,"Longest Consecutive Sequence
Solved 
Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.

A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.

You must write an algorithm that runs in O(n) time.

Example 1:

Input: nums = [2,20,4,10,3,4,5]

Output: 4
Explanation: The longest consecutive sequence is [2, 3, 4, 5].

Example 2:

Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
Constraints:

0 <= nums.length <= 1000
-10^9 <= nums[i] <= 10^9","# class Solution:
#     def longestConsecutive(self, nums: List[int]) -> int:
#         dic = defaultdict(int)

#         for i in range(len(nums)):
#             val = nums[i]
#             if nums[i] - 1  in dic.keys():
#                 dic[nums[i]] = max (dic[nums[i]], dic[nums[i] - 1]+1)
#             else:
#                 dic[nums[i]] = 1
#         return max(dic.values())
import heapq
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        dic = defaultdict(int)
        
        keys_list = []
        for i in range(len(nums)):
            val = nums[i]
            dic[val] = 1
            heapq.heappush(keys_list, val)
        
        for i in range(len(keys_list)):
            key = heapq.heappop(keys_list)
            dic[key] = max(dic[key], dic[key-1]+1)
        
        return max(dic.values())
            "
,Valid Palindrome,Easy,Two Pointer,"Valid Palindrome
Solved 
Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

Note: Alphanumeric characters consist of letters (A-Z, a-z) and numbers (0-9).

Example 1:

Input: s = ""Was it a car or a cat I saw?""

Output: true
Explanation: After considering only alphanumerical characters we have ""wasitacaroracatisaw"", which is a palindrome.

Example 2:

Input: s = ""tab a cat""

Output: false
Explanation: ""tabacat"" is not a palindrome.

Constraints:

1 <= s.length <= 1000
s is made up of only printable ASCII characters.","class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) -1
        s = s.lower()

        while left < right:
            print(f""s[left]: {s[left]}, s[left].isalnum(): {s[left].isalnum()}"")
            if s[left].isalnum() == False:
                left +=1
                continue
            print(f""s[right]: {s[right]}, s[right].isalnum(): {s[right].isalnum()}"")
            if s[right].isalnum() == False:
                right -=1
                continue
            if s[left] != s[right]:
                return False
            left +=1
            right -=1
        
        return True"
,Two Integer Sum II,Medium,Two Pointer,"Two Integer Sum II
Solved 
Given an array of integers numbers that is sorted in non-decreasing order.

Return the indices (1-indexed) of two numbers, [index1, index2], such that they add up to a given target number target and index1 < index2. Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.

There will always be exactly one valid solution.

Your solution must use 
O
(
1
)
O(1) additional space.

Example 1:

Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
Explanation:
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, index1 = 1, index2 = 2. We return [1, 2].

Constraints:

2 <= numbers.length <= 1000
-1000 <= numbers[i] <= 1000
-1000 <= target <= 1000","class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:

        left = 0
        right = len(numbers)-1
        

        while left < right:
            total = numbers[left] + numbers[right]
            if total == target:
                return [left+1, right+1]

            if total < target:
                left += 1
            
            if total > target:
                right -= 1
        
        return [-1,-1]
        "
,3Sum,Medium,Two Pointer,"3Sum
Solved 
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == 0, and the indices i, j and k are all distinct.

The output should not contain any duplicate triplets. You may return the output and the triplets in any order.

Example 1:

Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].

Example 2:

Input: nums = [0,1,1]

Output: []
Explanation: The only possible triplet does not sum up to 0.

Example 3:

Input: nums = [0,0,0]

Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.

Constraints:

3 <= nums.length <= 1000
-10^5 <= nums[i] <= 10^5","class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        nums.sort()
        ans = []
        for i in range(len(nums)-2):
            left = i + 1
            right = len(nums)-1
            if nums[i] > 0:
                break
            if i > 0 and nums[i] == nums[i-1]:
                continue

            while left < right:
                total = nums[i] + nums[left] + nums[right]

                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1
                else :
                    ans.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    
                    while nums[left] == nums[left-1] and left < right:
                        left += 1
                
                
            
        return ans

        "
,4Sum,Medium,Array & Hashing,"4Sum
Solved
Medium
Topics
premium lock icon
Companies
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

 

Example 1:

Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
Example 2:

Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
 

Constraints:

1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109","class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)

        res = set([])

        for i in range(n-3):
            if i>0 and nums[i] == nums[i-1]:
                continue
            for j in range(i+1, n-2):
                if j>i+1 and nums[j] == nums[j-1]:
                    continue
                left = j + 1
                right = n-1

                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]

                    if total == target:
                         res.add((nums[i], nums[j], nums[left], nums[right]))
                         left += 1
                    elif total < target:
                        left += 1
                    else:
                        right -= 1
        ans = []
        for p in res:
            ans.append(list(p))
        return ans
        "
,Rotate Array,Medium,Array & Hashing,"Rotate Array
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

 

Example 1:

Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
 

Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105","class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""

        k = k % len(nums)

        def reverse(left, right):
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left+=1
                right-= 1
            
            return

        reverse(0, len(nums)-1)
        reverse(0, k-1)
        reverse(k, len(nums)-1)
        
        return nums
        "
,Container With Most Water,Medium,Two Pointer,"Container With Most Water
Solved 
You are given an integer array heights where heights[i] represents the height of the 
i
t
h
i 
th
  bar.

You may choose any two bars to form a container. Return the maximum amount of water a container can store.

Example 1:



Input: height = [1,7,2,5,4,7,3,6]

Output: 36
Example 2:

Input: height = [2,2,2]

Output: 4
Constraints:

2 <= height.length <= 1000
0 <= height[i] <= 1000","class Solution:
    def maxArea(self, heights: List[int]) -> int:
        left = 0
        right = len(heights) - 1

        area = 0
        while left < right:
            lh = heights[left]
            rh = heights[right]
            area = max(area, min(lh, rh) * (right-left))

            if lh <= rh:
                left += 1
            else:
                right -= 1
        
        return area"
,Boats to Save People,Medium,Two Pointer,"Boats to Save People
Solved
Medium
Topics
premium lock icon
Companies
You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.

 

Example 1:

Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)
Example 2:

Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)
Example 3:

Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)
 

Constraints:

1 <= people.length <= 5 * 104
1 <= people[i] <= limit <= 3 * 104","class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()

        left = 0
        right = len(people) -1
        boat = 0

        while left < right:
            total_weight = people[left] + people[right]

            if total_weight > limit:
                right -= 1  
            else:
                left += 1
                right -= 1
            
            boat += 1
        if left == right:
            boat += 1
        return boat"
,Trapping Rain Water,Hard,Two Pointer,"Trapping Rain Water
Solved 
You are given an array of non-negative integers height which represent an elevation map. Each value height[i] represents the height of a bar, which has a width of 1.

Return the maximum area of water that can be trapped between the bars.

Example 1:



Input: height = [0,2,0,3,1,0,1,3,2,1]

Output: 9
Constraints:

1 <= height.length <= 1000
0 <= height[i] <= 1000","class Solution:
    def trap(self, height: List[int]) -> int:
        
        left = 0
        right = len(height) - 1

        max_l = 0
        max_r = len(height) - 1
        area = 0
# height=[0,1,0,2,1,0,1,3,2,1,2,1]
#        1
#    1   11 1
# _1_11_111111
        while left < right:
            print(f""left: {left}, max_l: {max_l}, height[left]: {height[left]}, height[max_l]: {height[max_l]}"")
            print(f""right: {right}, max_r: {max_r}, height[right]: {height[right]}, height[max_r]: {height[max_r]}"")
            print(f""area before: {area}"")

            if height[left] >= height[max_l]:
                max_l = left
            else:
                area += (height[max_l] - height[left])

            
            if height[right] >= height[max_r]:
                max_r = right
            else:
                area += (height[max_r] - height[right])
            print(f""area after: {area}\n\n"")

            if height[max_l] <= height[max_r]:
                left += 1
            else:
                right -= 1
        
        return area
            "
,Best Time to Buy and Sell Stock,Easy,Sliding Window,"Best Time to Buy and Sell Stock
Solved 
You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.

Example 1:

Input: prices = [10,1,5,6,7,1]

Output: 6
Explanation: Buy prices[1] and sell prices[4], profit = 7 - 1 = 6.

Example 2:

Input: prices = [10,8,7,5,2]

Output: 0
Explanation: No profitable transactions can be made, thus the max profit is 0.

Constraints:

1 <= prices.length <= 100
0 <= prices[i] <= 100","class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        left = 0
        right = 0

        profit = 0

        while right < len(prices):
            pl = prices[left]
            pr = prices[right]

            profit = max(profit, (pr - pl))
            if pr < pl:
                left = right
            
            right += 1
        
        return profit"
,Longest Substring Without Repeating Characters,Medium,Sliding Window,"Longest Substring Without Repeating Characters
Solved 
Given a string s, find the length of the longest substring without duplicate characters.

A substring is a contiguous sequence of characters within a string.

Example 1:

Input: s = ""zxyzxyz""

Output: 3
Explanation: The string ""xyz"" is the longest without duplicate characters.

Example 2:

Input: s = ""xxxx""

Output: 1
Constraints:

0 <= s.length <= 1000
s may consist of printable ASCII characters.","class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        alpha = defaultdict(lambda: -1)

        left = 0
        right = 0

        max_length = 0
        while right < len(s):
            letter = s[right]

            if alpha[letter] == -1:
                alpha[letter] = right
            else:
                left = max(left, alpha[letter] + 1)
                alpha[letter] = right
            print(f""left: {left}, right: {right}, (right - left): {(right - left)}, max_length: {max_length}"")
            max_length = max(max_length, (right - left) + 1)
            print(f""left: {left}, right: {right}, (right - left): {(right - left)}, max_length: {max_length}"")

            right += 1
        
        return max_length"
,Longest Repeating Character Replacement,Medium,Sliding Window,"Longest Repeating Character Replacement
Solved 
You are given a string s consisting of only uppercase english characters and an integer k. You can choose up to k characters of the string and replace them with any other uppercase English character.

After performing at most k replacements, return the length of the longest substring which contains only one distinct character.

Example 1:

Input: s = ""XYYX"", k = 2

Output: 4
Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

Example 2:

Input: s = ""AAABABB"", k = 1

Output: 5
Constraints:

1 <= s.length <= 1000
0 <= k <= s.length","class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        
        count = defaultdict(int)
        left = 0
        right = 0
        max_length = 0

        while right < len(s):
            r_letter = s[right]

            count[r_letter] += 1

            # loop to check if we exceed used replacements
            # length of window minus most frequent character occurance
            # the remainder letters need to be replaced
            # if exceed move the left pointer and keep the count of the window

            while (right - left + 1) - max(count.values()) > k:
                l_letter = s[left]

                count[l_letter] -= 1
                left += 1
            
            # now a valid window, check if it is the largest size window
            max_length = max(max_length, (right - left) + 1)
            right += 1
        
        return max_length
"
,Permutation in String,Medium,Sliding Window,"Permutation in String
Solved 
You are given two strings s1 and s2.

Return true if s2 contains a permutation of s1, or false otherwise. That means if a permutation of s1 exists as a substring of s2, then return true.

Both strings only contain lowercase letters.

Example 1:

Input: s1 = ""abc"", s2 = ""lecabee""

Output: true
Explanation: The substring ""cab"" is a permutation of ""abc"" and is present in ""lecabee"".

Example 2:

Input: s1 = ""abc"", s2 = ""lecaabee""

Output: false
Constraints:

1 <= s1.length, s2.length <= 1000","# class Solution:
#     def checkInclusion(self, s1: str, s2: str) -> bool:
#         n = len(s1)
#         word_dic = defaultdict(int)

#         for letter in s1:
#             word_dic[letter] += 1
        
#         def check_solutions(word_dic, s):
#             for letter in s:
#                 if word_dic[letter] != 0:
#                     return False
#             return True
        
#         left = 0
#         right = 0
#         word_dic[s2[right]] -= 1


#         while right < len(s2):
#             print(f""s1: {s1}, s2: {s2[left:right+1]}"")
#             if right - left + 1 == len(s1):
#                 print(f""word_dic: {word_dic}"")
#                 if check_solutions(word_dic, s1):
#                     return True
#                 right += 1
#                 if right  >= len(s2):
#                     return False
#                 letter_add = s2[right]
#                 letter_removed = s2[left]
#                 word_dic[letter_add] -= 1
#                 word_dic[letter_removed] += 1
#                 left += 1
#             elif right - left < len(s1): 
#                 print(f""moving right pointer"")
#                 right += 1
#                 if right  >= len(s2):
#                     return False
#                 letter_add = s2[right]
#                 word_dic[letter_add] -= 1
#             else:
#                 print(f""moving left pointer"")
#                 letter_removed = s2[left]
#                 word_dic[letter_removed] += 1
#                 left += 1
        
#         return False

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
            
        s1_dic = defaultdict(int)
        s2_dic = defaultdict(int)

        matches = 0

        for i in range(len(s1)):
            s1_dic[s1[i]] += 1
            s2_dic[s2[i]] += 1
        
        for i in range(26):
            letter = chr(ord('a') + i)
            if s1_dic[letter] == s2_dic[letter]:
                matches += 1
        
        left = 0
        right = len(s1)

        while right < len(s2):
            if matches == 26:
                return True
            
            letter_r = s2[right]
            letter_l = s2[left]

            s2_dic[letter_r] += 1
            if s2_dic[letter_r] == s1_dic[letter_r]:
                matches += 1
            elif s2_dic[letter_r]-1 == s1_dic[letter_r]:
                matches -= 1
            

            s2_dic[letter_l] -= 1
            if s2_dic[letter_l] == s1_dic[letter_l]:
                matches += 1
            elif s2_dic[letter_l]+1 == s1_dic[letter_l]:
                matches -= 1
            
            left += 1
            right += 1
        
        return matches == 26"
,Minimum Window Substring,Hard,Sliding Window,"Minimum Window Substring
Solved 
Given two strings s and t, return the shortest substring of s such that every character in t, including duplicates, is present in the substring. If such a substring does not exist, return an empty string """".

You may assume that the correct output is always unique.

Example 1:

Input: s = ""OUZODYXAZV"", t = ""XYZ""

Output: ""YXAZ""
Explanation: ""YXAZ"" is the shortest substring that includes ""X"", ""Y"", and ""Z"" from string t.

Example 2:

Input: s = ""xyz"", t = ""xyz""

Output: ""xyz""
Example 3:

Input: s = ""x"", t = ""xy""

Output: """"
Constraints:

1 <= s.length <= 1000
1 <= t.length <= 1000
s and t consist of uppercase and lowercase English letters.","# class Solution:
#     def minWindow(self, s: str, t: str) -> str:
#         t_dic = defaultdict(int)
#         s_dic = defaultdict(int)
        
#         def compare(tcom, scom):
#             for letter in t:
#                 if t_dic[letter] > s_dic[letter]:
#                     return False
#             return True
        
#         for letter in t:
#             t_dic[letter] += 1
#         left = 0
#         res = ''
#         min_res = ''
#         for right in range(len(s)):
#             res += s[right]
#             s_dic[s[right]] += 1
            
#             comp_res = compare(t_dic, s_dic)
#             while compare(t_dic, s_dic):
#                 if min_res == '':
#                     min_res = res
#                 elif min_res != '' and len(res) < len(min_res):
#                     min_res = res
                
#                 s_dic[s[left]] -= 1
#                 res = res[1:]
#                 left += 1

#         return min_res


class Solution:
    def minWindow(self, s: str, t: str) -> str:
        t_dic = defaultdict(int)
        s_dic = defaultdict(int)
        
        def compare(tcom, scom):
            for letter in t:
                if t_dic[letter] > s_dic[letter]:
                    return False
            return True
        
        for letter in t:
            t_dic[letter] += 1
        need = len(t_dic)
        left = 0
        res = ''
        min_res = ''
        have = 0
        for right in range(len(s)):
            res += s[right]
            s_dic[s[right]] += 1
            if s_dic[s[right]] == t_dic[s[right]]:
                have += 1
            
            
            while have == need:
                print(f""have: {have}, need: {need}, res: {res}"")
                if min_res == '':
                    min_res = res
                elif min_res != '' and len(res) < len(min_res):
                    min_res = res
                
                
                if s[left] in t_dic.keys():
                    if s_dic[s[left]] == t_dic[s[left]]:
                        have -= 1
                        
                s_dic[s[left]] -= 1
                res = res[1:]
                left += 1

        return min_res
                    
                    
                    
                    "
,Sliding Window Maximum,Hard,Sliding Window,"Sliding Window Maximum
Solved 
You are given an array of integers nums and an integer k. There is a sliding window of size k that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.

Return a list that contains the maximum element in the window at each step.

Example 1:

Input: nums = [1,2,1,0,4,2,6], k = 3

Output: [2,2,4,4,6]

Explanation: 
Window position            Max
---------------           -----
[1  2  1] 0  4  2  6        2
 1 [2  1  0] 4  2  6        2
 1  2 [1  0  4] 2  6        4
 1  2  1 [0  4  2] 6        4
 1  2  1  0 [4  2  6]       6
Constraints:

1 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
1 <= k <= nums.length","# class Solution:
#     def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
#         res = []
#         for i in range(len(nums)-k+1):
#             res.append(max(nums[i:i+k]))
#         return res

import heapq as hq
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        pq = []
        res = []
        for i in range(len(nums)):
            hq.heappush(pq, (-1 * nums[i], i))
            if i >= k - 1:
                while pq[0][1] <= i - k: # while idx of the largest value in the window 
                                         # is leq to the idx of the element being removed
                                         # from the window we remove it
                    hq.heappop(pq)       
                res.append(-1*pq[0][0])
        return res
                "
,Valid Parentheses,Easy,Stack,"Valid Parentheses
Solved 
You are given a string s consisting of the following characters: '(', ')', '{', '}', '[' and ']'.

The input string s is valid if and only if:

Every open bracket is closed by the same type of close bracket.
Open brackets are closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Return true if s is a valid string, and false otherwise.

Example 1:

Input: s = ""[]""

Output: true
Example 2:

Input: s = ""([{}])""

Output: true
Example 3:

Input: s = ""[(])""

Output: false
Explanation: The brackets are not closed in the correct order.

Constraints:

1 <= s.length <= 1000","class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c in ('(', '{', '['):
                stack.append(c)
            else:
                if len(stack) == 0:
                    return False
                    
                if (c == ')' and stack[-1] != '(') or \
                   (c == '}' and stack[-1] != '{') or \
                   (c == ']' and stack[-1] != '['):
                   return False
                else:
                    stack.pop()
        
        return stack == []
"
,Minimum Stack,Medium,Stack,"Minimum Stack
Solved 
Design a stack class that supports the push, pop, top, and getMin operations.

MinStack() initializes the stack object.
void push(int val) pushes the element val onto the stack.
void pop() removes the element on the top of the stack.
int top() gets the top element of the stack.
int getMin() retrieves the minimum element in the stack.
Each function should run in 
O
(
1
)
O(1) time.

Example 1:

Input: [""MinStack"", ""push"", 1, ""push"", 2, ""push"", 0, ""getMin"", ""pop"", ""top"", ""getMin""]

Output: [null,null,null,null,0,null,2,1]

Explanation:
MinStack minStack = new MinStack();
minStack.push(1);
minStack.push(2);
minStack.push(0);
minStack.getMin(); // return 0
minStack.pop();
minStack.top();    // return 2
minStack.getMin(); // return 1
Constraints:

-2^31 <= val <= 2^31 - 1.
pop, top and getMin will always be called on non-empty stacks.","class MinStack:

    def __init__(self):
        self.stack = []
        self.min_ele_idx = []
        

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.min_ele_idx == []:
            self.min_ele_idx.append(len(self.stack)-1)
        else:
            curr_min_idx = self.min_ele_idx[-1]
            curr_min_val = self.stack[curr_min_idx]

            if curr_min_val >= val:
                self.min_ele_idx.append(len(self.stack)-1)
            else:
                self.min_ele_idx.append(curr_min_idx)




    def pop(self) -> None:
        n = len(self.stack)
        if n > 0:
            
            self.min_ele_idx.pop()
            self.stack.pop()
        
        

    def top(self) -> int:
        if len(self.stack) == 0:
            return None
        return self.stack[-1]
        

    def getMin(self) -> int:
        curr_min_idx = self.min_ele_idx[-1]
        curr_min_val = self.stack[curr_min_idx]
        return curr_min_val
        "
,Evaluate Reverse Polish Notation,Medium,Stack,"Evaluate Reverse Polish Notation
Solved 
You are given an array of strings tokens that represents a valid arithmetic expression in Reverse Polish Notation.

Return the integer that represents the evaluation of the expression.

The operands may be integers or the results of other operations.
The operators include '+', '-', '*', and '/'.
Assume that division between integers always truncates toward zero.
Example 1:

Input: tokens = [""1"",""2"",""+"",""3"",""*"",""4"",""-""]

Output: 5

Explanation: ((1 + 2) * 3) - 4 = 5
Constraints:

1 <= tokens.length <= 1000.
tokens[i] is ""+"", ""-"", ""*"", or ""/"", or a string representing an integer in the range [-100, 100].","class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for c in tokens:
            if c == ""+"":
                val_two = int(stack.pop())
                val_one = int(stack.pop())
                stack.append(val_one + val_two)
            elif c == ""-"":
                val_two = int(stack.pop())
                val_one = int(stack.pop())
                stack.append(val_one - val_two)
            elif c == ""*"":
                val_two = int(stack.pop())
                val_one = int(stack.pop())
                stack.append(val_one * val_two)
            elif c == ""/"":
                val_two = int(stack.pop())
                val_one = int(stack.pop())
                stack.append(val_one / val_two)
            else:
                stack.append(c)
        
        return int(stack[-1])
        "
,Generate Parentheses,Medium,Stack,"Generate Parentheses
Solved 
You are given an integer n. Return all well-formed parentheses strings that you can generate with n pairs of parentheses.

Example 1:

Input: n = 1

Output: [""()""]
Example 2:

Input: n = 3

Output: [""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]
You may return the answer in any order.

Constraints:

1 <= n <= 7","class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        def rec(c_stack, num, path):
            if num == 0 and c_stack==[]:
                ans.append(path)
                return
            
            if num > 0:
                path += ""(""
                c_stack.append("")"")
                rec(c_stack, num-1, path)
                path = path[:-1]
                c_stack.pop()

            if c_stack != []:
                path += c_stack.pop()
                rec(c_stack, num, path)
                path = path[:-1]
                c_stack.append("")"")
            
        
        rec([], n, """")
        return ans"
,Daily Temperatures,Medium,Stack,"Daily Temperatures
Solved 
You are given an array of integers temperatures where temperatures[i] represents the daily temperatures on the ith day.

Return an array result where result[i] is the number of days after the ith day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the ith day, set result[i] to 0 instead.

Example 1:

Input: temperatures = [30,38,30,36,35,40,28]

Output: [1,4,1,2,1,0,0]
Example 2:

Input: temperatures = [22,21,20]

Output: [0,0,0]
Constraints:

1 <= temperatures.length <= 1000.
1 <= temperatures[i] <= 100","class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = [temperatures[0]]
        res = []
        for i in range(1, len(temperatures)):

            if stack[-1] >= temperatures[i]:
                stack.append(temperatures[i])
            else:
                count = 1
                while stack != [] and stack[-1] < temperatures[i]:
                    res.append(count)
                    stack.pop()
                    count += 1
                stack.append(temperatures[i])
        return res[::-1]



class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack_idx = [0]
        res = [0] * len(temperatures)
        for i in range(1, len(temperatures)):
            if stack_idx != []:
                s_idx = stack_idx[-1]
                stack_temp = temperatures[s_idx]

                while stack_idx != [] and temperatures[i] > stack_temp:
                    res[s_idx] = i - s_idx
                    stack_idx.pop()
                    if stack_idx != []:
                        s_idx = stack_idx[-1]
                        stack_temp = temperatures[s_idx]
                
            stack_idx.append(i)

        return res

# _
# 28. 0
# 40. 0
# 35  1
# 36  2
#     1
# 38. 4
#     1

# 6
# 5
# 4. 5-4 =1
# 3  5-3 = 2
#    3-2 = 1
# 1. 5- 1 =4
#    1-0 = 1

        "
,Car Fleet,Medium,Stack,"Car Fleet
Solved 
There are n cars traveling to the same destination on a one-lane highway.

You are given two arrays of integers position and speed, both of length n.

position[i] is the position of the ith car (in miles)
speed[i] is the speed of the ith car (in miles per hour)
The destination is at position target miles.

A car can not pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.

A car fleet is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.

If a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.

Return the number of different car fleets that will arrive at the destination.

Example 1:

Input: target = 10, position = [1,4], speed = [3,2]

Output: 1
Explanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.

Example 2:

Input: target = 10, position = [4,1,0,7], speed = [2,2,1,1]

Output: 3
Explanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.

Constraints:

n == position.length == speed.length.
1 <= n <= 1000
0 < target <= 1000
0 < speed[i] <= 100
0 <= position[i] < target
All the values of position are unique.","class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:

        combo = []

        for p, s in zip(position, speed):
            combo.append((p,s))

        combo.sort(reverse = True)
        print(combo)

        stack = [(target-combo[0][0])/combo[0][1]]

        count = 1
        for i in range(1,len(combo)):
            time_to_target = (target-combo[i][0])/combo[i][1]
            if time_to_target > stack[-1]:
                count+=1
                stack.append(time_to_target)

        print(stack)
        return count"
,Binary Search,Easy,Binary Search,"Binary Search
Solved 
You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in 
O
(
l
o
g
n
)
O(logn) time.

Example 1:

Input: nums = [-1,0,2,4,6,8], target = 4

Output: 3
Example 2:

Input: nums = [-1,0,2,4,6,8], target = 3

Output: -1
Constraints:

1 <= nums.length <= 10000.
-10000 < nums[i], target < 10000
All the integers in nums are unique.","class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1

        # while left < right:
        #     mid = left + (right - left)//2

        #     if target <= nums[mid]:
        #         right = mid
        #     else:
        #         left = mid + 1
        

        while left < right:
            mid = left + math.ceil((right - left)/2)

            if target < nums[mid]:
                right = mid - 1
            else:
                left = mid
            
        
        return left if nums[left] == target else -1"
,Search a 2D Matrix,Medium,Binary Search,"Search a 2D Matrix
Solved 
You are given an m x n 2-D integer array matrix and an integer target.

Each row in matrix is sorted in non-decreasing order.
The first integer of every row is greater than the last integer of the previous row.
Return true if target exists within matrix or false otherwise.

Can you write a solution that runs in O(log(m * n)) time?

Example 1:



Input: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10

Output: true
Example 2:



Input: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15

Output: false
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-10000 <= matrix[i][j], target <= 10000","class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        #binary search row
        low = 0
        high = len(matrix) -1

        while low < high:
            mid = low + (high - low) // 2

            if target > matrix[mid][-1]:
                low = mid + 1
            elif target < matrix[mid][0]:
                high = mid - 1
            else:
                high = mid
        
        row = high

        # binary search col
        left = 0
        right = len(matrix[0]) - 1

        while left < right:
            mid = left + (right - left) // 2

            if target > matrix[row][mid]:
                left = mid + 1
            else:
                right = mid
        
        col = right

        return True if matrix[row][col] == target else False"
,Koko Eating Bananas,Medium,Binary Search,"Koko Eating Bananas
Solved 
You are given an integer array piles where piles[i] is the number of bananas in the ith pile. You are also given an integer h, which represents the number of hours you have to eat all the bananas.

You may decide your bananas-per-hour eating rate of k. Each hour, you may choose a pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, you may finish eating the pile but you can not eat from another pile in the same hour.

Return the minimum integer k such that you can eat all the bananas within h hours.

Example 1:

Input: piles = [1,4,3,2], h = 9

Output: 2
Explanation: With an eating rate of 2, you can eat the bananas in 6 hours. With an eating rate of 1, you would need 10 hours to eat all the bananas (which exceeds h=9), thus the minimum eating rate is 2.

Example 2:

Input: piles = [25,10,23,4], h = 4

Output: 25
Constraints:

1 <= piles.length <= 1,000
piles.length <= h <= 1,000,000
1 <= piles[i] <= 1,000,000,000","class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:

        def eating_time(eating_rate):
            total_time = 0
            for pile in piles:
                total_time += math.ceil(pile/eating_rate)
            return total_time
        
        low = 1
        high = max(piles)

        while low < high:
            eating_rate = low + (high - low)//2

            hours_taken = eating_time(eating_rate)

            # if taking too long, increase lower bound of eating rate
            if hours_taken > h:
                low = eating_rate + 1
            else:
                high = eating_rate
        
        return low
            
        "
,Find Minimum in Rotated Sorted Array,Medium,Binary Search,"Find Minimum in Rotated Sorted Array
Solved 
You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:

[3,4,5,6,1,2] if it was rotated 4 times.
[1,2,3,4,5,6] if it was rotated 6 times.
Notice that rotating the array 4 times moves the last four elements of the array to the beginning. Rotating the array 6 times produces the original array.

Assuming all elements in the rotated sorted array nums are unique, return the minimum element of this array.

A solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?

Example 1:

Input: nums = [3,4,5,6,1,2]

Output: 1
Example 2:

Input: nums = [4,5,0,1,2,3]

Output: 0
Example 3:

Input: nums = [4,5,6,7]

Output: 4
Constraints:

1 <= nums.length <= 1000
-1000 <= nums[i] <= 1000","class Solution:
    def findMin(self, nums: List[int]) -> int:

        left = 0
        right = len(nums) - 1

        while left < right:
            mid = left + (right - left)//2

            if nums[mid] > nums[left]:
                # regular array find left
                # [1,2,3,4*,5,6]
                if nums[right] >= nums[mid]:
                    right = mid

                # else smallest value is on right of mid
                # so move left up
                # [2,3,4,5*,6,1]
                else: 
                    left = mid + 1
            
            else:
                # [6,1,2,3*,4,5]
                # want to decrease and move left so we decrease right
                if nums[right] >= nums[mid]:
                    right = mid

                # [3,4,5,6*,1,2]
                # want to increase and move right so we increase left
                else: 
                    left = mid + 1
        
        return nums[right]

        "
,Search in Rotated Sorted Array,Medium,Binary Search,"Search in Rotated Sorted Array
Solved 
You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:

[3,4,5,6,1,2] if it was rotated 4 times.
[1,2,3,4,5,6] if it was rotated 6 times.
Given the rotated sorted array nums and an integer target, return the index of target within nums, or -1 if it is not present.

You may assume all elements in the sorted rotated array nums are unique,

A solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?

Example 1:

Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
Example 2:

Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
Constraints:

1 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
-1000 <= target <= 1000","class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1

        while left < right:
            mid = left + (right - left)//2

            if nums[mid] > nums[left]:
                #[5,6,1,2*,3~,4]    mid = *, target = ~
                if nums[right] > nums[mid] and target > nums[mid] and target > nums[right]:
                    right = mid
                elif nums[right] > nums[mid] and target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                #[5,6,~1,2*,3,4]    mid = *, target = ~
                elif nums[right] > nums[mid] and target <= nums[mid]:
                    right = mid
                #[3,4,5*,6,1~,2]
                elif nums[right] <= nums[mid] and target < nums[mid] and target > nums[right]:
                    right = mid
                #[3,4~,5*,6,1,2]
                elif nums[right] <= nums[mid] and target < nums[mid] and target <= nums[right]:
                    left = mid + 1
                elif nums[right] <= nums[mid] and target >= nums[mid] and target > nums[right]:
                    left = mid + 1
            
            else:

                #[5,6,1,2*,3~,4]    mid = *, target = ~
                if nums[right] > nums[mid] and target > nums[mid] and target > nums[right]:
                    right = mid
                elif nums[right] > nums[mid] and target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                #[5,6,~1,2*,3,4]    mid = *, target = ~
                elif nums[right] > nums[mid] and target <= nums[mid]:
                    right = mid
                #[3,4,5*,6,1~,2]
                elif nums[right] <= nums[mid] and target < nums[mid] and target > nums[right]:
                    right = mid
                #[3,4~,5*,6,1,2]
                elif nums[right] <= nums[mid] and target < nums[mid] and target <= nums[right]:
                    left = mid + 1
                elif nums[right] <= nums[mid] and target >= nums[mid] and target > nums[right]:
                    right = mid

        return left if nums[left] == target else -1"
,Time Based Key-Value Store,Medium,Binary Search,"Time Based Key-Value Store
Solved 
Implement a time-based key-value data structure that supports:

Storing multiple values for the same key at specified time stamps
Retrieving the key's value at a specified timestamp
Implement the TimeMap class:

TimeMap() Initializes the object.
void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.
String get(String key, int timestamp) Returns the most recent value of key if set was previously called on it and the most recent timestamp for that key prev_timestamp is less than or equal to the given timestamp (prev_timestamp <= timestamp). If there are no values, it returns """".
Note: For all calls to set, the timestamps are in strictly increasing order.

Example 1:

Input:
[""TimeMap"", ""set"", [""alice"", ""happy"", 1], ""get"", [""alice"", 1], ""get"", [""alice"", 2], ""set"", [""alice"", ""sad"", 3], ""get"", [""alice"", 3]]

Output:
[null, null, ""happy"", ""happy"", null, ""sad""]

Explanation:
TimeMap timeMap = new TimeMap();
timeMap.set(""alice"", ""happy"", 1);  // store the key ""alice"" and value ""happy"" along with timestamp = 1.
timeMap.get(""alice"", 1);           // return ""happy""
timeMap.get(""alice"", 2);           // return ""happy"", there is no value stored for timestamp 2, thus we return the value at timestamp 1.
timeMap.set(""alice"", ""sad"", 3);    // store the key ""alice"" and value ""sad"" along with timestamp = 3.
timeMap.get(""alice"", 3);           // return ""sad""
Constraints:

1 <= key.length, value.length <= 100
key and value only include lowercase English letters and digits.
1 <= timestamp <= 1000","import heapq as hq
class TimeMap:

    def __init__(self):
        self.dic = defaultdict(list)
        
        

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.dic[key].append((timestamp, value))
        
    def binary_search_convergence(self, li, timestamp: int) -> int:
        left = 0
        right = len(li)-1
        mid = 0
        while left < right:
            mid = left + math.ceil((right-left) / 2)
            ts, val = li[mid]
            
            if ts > timestamp:
                right = mid -1
            elif ts < timestamp:
                left = mid
            else:
                return mid

        return right
    
    def binary_search_classic(self, li, timestamp: int) -> int:
        left = 0
        right = len(li)-1
        mid = 0
        while left <= right:
            mid = left + (right-left) // 2
            ts, val = li[mid]
            
            if ts > timestamp:
                right = mid -1
            elif ts < timestamp:
                left = mid + 1
            else:
                 return mid

        return right

    def get(self, key: str, timestamp: int) -> str:
        if self.dic[key] == []:
            return """"
        idx = self.binary_search_classic(self.dic[key], timestamp)
        print(f""idx: {idx}"")
        ts, val = self.dic[key][idx]
        if ts <= timestamp:
            return val
        return """"
        "
,Reverse Linked List,Easy,Linked List,"Reverse Linked List
Solved 
Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.

Example 1:

Input: head = [0,1,2,3]

Output: [3,2,1,0]
Example 2:

Input: head = []

Output: []
Constraints:

0 <= The length of the list <= 1000.
-1000 <= Node.val <= 1000","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None

        while head:
            next = head.next
            head.next = prev
            prev = head
            head = next


        return prev
        "
,Merge Two Sorted Linked Lists,Easy,Linked List,"Merge Two Sorted Linked Lists
Solved 
You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from list1 and list2.

Example 1:



Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
Example 2:

Input: list1 = [], list2 = [1,2]

Output: [1,2]
Example 3:

Input: list1 = [], list2 = []

Output: []
Constraints:

0 <= The length of the each list <= 100.
-100 <= Node.val <= 100","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if list1 and not list2:
            return list1
        elif not list1 and list2:
            return list2
        elif not list1 and not list2:
            return None

        head = None
        if list1.val <= list2.val:
            head = list1
            list1 = list1.next
        else:
            head = list2
            list2 = list2.next
        
        curr = head
        while list1 and list2:
            if list2.val <= list1.val:
                head.next = list2
                list2 = list2.next
                head = head.next
                if head:
                    head.next = None
            else:
                head.next = list1
                list1 = list1.next
                head = head.next
                if head:
                    head.next = None


        if list1:
            head.next = list1
        
        if list2:
            head.next = list2
        
        return curr
        "
,Linked List Cycle Detection,Easy,Linked List,"Linked List Cycle Detection
Solved 
Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.

There is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.

Internally, index determines the index of the beginning of the cycle, if it exists. The tail node of the list will set it's next pointer to the index-th node. If index = -1, then the tail node points to null and no cycle exists.

Note: index is not given to you as a parameter.

Example 1:



Input: head = [1,2,3,4], index = 1

Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

Example 2:



Input: head = [1,2], index = -1

Output: false
Constraints:

1 <= Length of the list <= 1000.
-1000 <= Node.val <= 1000
index is -1 or a valid index in the linked list.","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:

        slow = head
        fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                return True
        
        return False
        "
,Reorder Linked List,Medium,Linked List,"Reorder Linked List
Solved 
You are given the head of a singly linked-list.

The positions of a linked list of length = 7 for example, can intially be represented as:

[0, 1, 2, 3, 4, 5, 6]

Reorder the nodes of the linked list to be in the following order:

[0, 6, 1, 5, 2, 4, 3]

Notice that in the general case for a list of length = n the nodes are reordered to be in the following order:

[0, n-1, 1, n-2, 2, n-3, ...]

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

Example 1:

Input: head = [2,4,6,8]

Output: [2,8,4,6]
Example 2:

Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
Constraints:

1 <= Length of the list <= 1000.
1 <= Node.val <= 1000","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if head.next is None:
            return

        #find midpoint
        slow = head
        fast = head
        prev = None

        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next
        
        

        #reverse second half
        head2 = slow
        prev.next = None
        prev = None

        while head2:
            next_node = head2.next
            head2.next = prev
            prev = head2
            head2 = next_node
        
        #merge linklist
        dummy = ListNode()
        dummy.next = head
        curr = dummy
        head1 = head
        head2 = prev

        is_odd = True
        while head1 and head2:

            if is_odd:
                curr.next = head1
                head1 = head1.next
            else:
                curr.next = head2
                head2 = head2.next
            
            curr = curr.next
            is_odd = not is_odd

        
        if head1:
            curr.next = head1
        
        if head2:
            curr.next = head2
        



        "
,Remove Node From End of Linked List,Medium,Linked List,"Remove Node From End of Linked List
Solved 
You are given the beginning of a linked list head, and an integer n.

Remove the nth node from the end of the list and return the beginning of the list.

Example 1:

Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
Example 2:

Input: head = [5], n = 1

Output: []
Example 3:

Input: head = [1,2], n = 2

Output: [2]
Constraints:

The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        #count nodes in list
        if head is None:
            return 

        list_len = 0
        temp = head
        while temp:
            list_len += 1
            temp = temp.next
        
        end_range = list_len - n 

        dummy = ListNode()
        dummy.next = head
        curr = dummy
        for i in range(end_range):
            curr = curr.next
        
        next_node = curr.next
        if next_node:
            next_node = next_node.next
        
        curr.next = next_node
        
        
        return dummy.next
        


        
        "
,Copy Linked List with Random Pointer,Medium,Linked List,"Copy Linked List with Random Pointer
Solved 
You are given the head of a linked list of length n. Unlike a singly linked list, each node contains an additional pointer random, which may point to any node in the list, or null.

Create a deep copy of the list.

The deep copy should consist of exactly n new nodes, each including:

The original value val of the copied node
A next pointer to the new node corresponding to the next pointer of the original node
A random pointer to the new node corresponding to the random pointer of the original node
Note: None of the pointers in the new list should point to nodes in the original list.

Return the head of the copied linked list.

In the examples, the linked list is represented as a list of n nodes. Each node is represented as a pair of [val, random_index] where random_index is the index of the node (0-indexed) that the random pointer points to, or null if it does not point to any node.

Example 1:



Input: head = [[3,null],[7,3],[4,0],[5,1]]

Output: [[3,null],[7,3],[4,0],[5,1]]
Example 2:



Input: head = [[1,null],[2,2],[3,2]]

Output: [[1,null],[2,2],[3,2]]
Constraints:

0 <= n <= 100
-100 <= Node.val <= 100
random is null or is pointing to some node in the linked list.","""""""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
""""""

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        #key real_node, val copy_node
        if head is None:
            return None
        node_dic = {}
        curr = head

        while curr:
            if curr not in node_dic.keys():
                copy_node = Node(x=curr.val)
                node_dic[curr] = copy_node

            if curr.next in node_dic.keys():
                node_dic[curr].next = node_dic[curr.next]
            elif curr.next:
                copy_node_next = Node(x=curr.next.val)
                node_dic[curr.next] = copy_node_next
                node_dic[curr].next = node_dic[curr.next]
            else:
                node_dic[curr].next = None
            

            if curr.random in node_dic.keys():
                node_dic[curr].random = node_dic[curr.random]
            elif curr.random:
                copy_node_random = Node(x=curr.random.val)
                node_dic[curr.random] = copy_node_random
                node_dic[curr].random = node_dic[curr.random]
            else:
                node_dic[curr].random = None
                        
            curr = curr.next
        
        for key, val in node_dic.items():
            print(f""key: {key.val}, copy: {val.val}"")
            if key.next:
                print(f""key next: {key.next.val}, copy next: {val.next.val}"")
            else:
                print(f""key next: {key.next}, copy next: {val.next}"")

            if key.random:    
                print(f""key random: {key.random.val}, copy random: {val.random.val}"")
            else:
                print(f""key random: {key.random}, copy random: {val.random}"")
            print()
        
        return node_dic[head]"
,Add Two Numbers,Medium,Linked List,"Add Two Numbers
Solved 
You are given two non-empty linked lists, l1 and l2, where each represents a non-negative integer.

The digits are stored in reverse order, e.g. the number 123 is represented as 3 -> 2 -> 1 -> in the linked list.

Each of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Return the sum of the two numbers as a linked list.

Example 1:



Input: l1 = [1,2,3], l2 = [4,5,6]

Output: [5,7,9]

Explanation: 321 + 654 = 975.
Example 2:

Input: l1 = [9], l2 = [9]

Output: [8,1]
Constraints:

1 <= l1.length, l2.length <= 100.
0 <= Node.val <= 9","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:

        def reverse_list(l):
            prev = None

            while l:
                next_node = l.next
                l.next = prev
                prev = l
                l = next_node
            
            return prev
        

        def add_lists(list_1, list_2):
            carry = 0
            new_val = list_1.val + list_2.val + carry
            carry = new_val // 10
            remainder = new_val % 10
            prev = ListNode(remainder)
            head = prev

            list_1 = list_1.next
            list_2 = list_2.next
            
            while list_1 or list_2:
                list1_val = 0
                if list_1:
                    list1_val = list_1.val
                
                list2_val = 0
                if list_2:
                    list2_val = list_2.val

                new_val = list1_val + list2_val + carry
                carry = new_val // 10
                remainder = new_val % 10
                node = ListNode(remainder)

                prev.next = node
                prev = node

                if list_1:
                    list_1 = list_1.next
                if list_2:
                    list_2 = list_2.next
            
            if carry == 1:
                node = ListNode(1)
                prev.next = node
                prev = node

            
            return head
        return add_lists(l1, l2)


# l1=[9,9,9,9,9,9,9]
# l2=[9,9,9,9]
#    [8,]
#    9 + 9 + carry 0 = 18, remainder 8 carry 1 = 8
#    9 + 9 + carry 1 = 19, remainder 9 carry 1 = 9
#    9 + 9 + carry 1 = 19, remainder 9 carry 1 = 9
#    9 + 9 + carry 1 = 19, remainder 9 carry 1 = 9
#    9 + 0 + carry 1 = 10, remainder 0 carry 1 = 0
#    9 + 0 + carry 1 = 10, remainder 0 carry 1 = 0
#    9 + 0 + carry 1 = 10, remainder 0 carry 1 = 0
#    0 + 0 + carry 1 = 1 , remainder 0 carry 0 = 1"
,Find the Duplicate Number,Medium,Linked List,"Find the Duplicate Number
Solved 
You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.

Every integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.

Example 1:

Input: nums = [1,2,3,2,2]

Output: 2
Example 2:

Input: nums = [1,2,3,4,4]

Output: 4
Follow-up: Can you solve the problem without modifying the array nums and using 
O
(
1
)
O(1) extra space?

Constraints:

1 <= n <= 10000
nums.length == n + 1
1 <= nums[i] <= n","class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # Use numbers in list to go to index
        # use fast and slow pointers concept
        # when fast and slow meet they are on the index
        # value that repeats

        slow = nums[0]
        fast = nums[0]

        slow = nums[slow]
        fast = nums[nums[fast]]

        looped = False
        while slow != fast:
            if looped == False:
                slow = nums[slow]
                fast = nums[nums[fast]]
            else:
                slow = nums[slow]
                fast = nums[fast]

            if slow == fast and looped == False:
                slow = nums[0]
                looped = True

        
        return slow"
,LRU Cache,Medium,Linked List,"LRU Cache
Solved 
Implement the Least Recently Used (LRU) cache class LRUCache. The class should support the following operations

LRUCache(int capacity) Initialize the LRU cache of size capacity.
int get(int key) Return the value corresponding to the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.
A key is considered used if a get or a put operation is called on it.

Ensure that get and put each run in 
O
(
1
)
O(1) average time complexity.

Example 1:

Input:
[""LRUCache"", [2], ""put"", [1, 10],  ""get"", [1], ""put"", [2, 20], ""put"", [3, 30], ""get"", [2], ""get"", [1]]

Output:
[null, null, 10, null, null, 20, -1]

Explanation:
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 10);  // cache: {1=10}
lRUCache.get(1);      // return 10
lRUCache.put(2, 20);  // cache: {1=10, 2=20}
lRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted
lRUCache.get(2);      // returns 20 
lRUCache.get(1);      // return -1 (not found)
Constraints:

1 <= capacity <= 100
0 <= key <= 1000
0 <= value <= 1000","class Node:

    def __init__(self, key: int, val: int):
        self.key = key
        self.val = val
        self.prev = None
        self.nex = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.dic = {}
        self.left = Node(0, 0) #pointer to least recently used 
        self.right = Node(0, 0) #pointer of most recently used
        self.left.nex = self.right #point pointers to eachother
        self.right.prev = self.left
    
    def remove(self, node):
        prev = node.prev # get nodes prev
        nex = node.nex # get nodes next
        prev.nex = nex # connect prev to the node's next skipping the node
        nex.prev = prev # connect nex to the node's prev skipping the node


    
    def insert(self, node):
        prev = self.right.prev #old most recently used
        nex = self.right # most recently used pointer identifier
        prev.nex = node  # old most recently used points to new recently used point
        nex.prev = node  # most recently used pointer identifier points back to new node for recently used 
        node.nex = nex   # make new most recently used node point to most recently used pointer identifier
        node.prev = prev # make new most recently used node point prev to old most recently used node

    def get(self, key: int) -> int:
        if key in self.dic.keys():
            self.remove(self.dic[key])
            self.insert(self.dic[key])
            return self.dic[key].val
        return -1
        

    def put(self, key: int, value: int) -> None:
        if key in self.dic.keys():
            self.remove(self.dic[key])
        self.dic[key] = Node(key, value)
        self.insert(self.dic[key])

        if len(self.dic) > self.capacity:
            lru = self.left.nex
            self.remove(lru)
            self.dic.pop(lru.key)

        "
,Merge K Sorted Linked Lists,Hard,Linked List,"Merge K Sorted Linked Lists
Solved 
You are given an array of k linked lists lists, where each list is sorted in ascending order.

Return the sorted linked list that is the result of merging all of the individual linked lists.

Example 1:

Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
Example 2:

Input: lists = []

Output: []
Example 3:

Input: lists = [[]]

Output: []
Constraints:

0 <= lists.length <= 1000
0 <= lists[i].length <= 100
-1000 <= lists[i][j] <= 1000","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# #First attempt logic
# import heapq as hq
# class Solution:    
#     def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
#         pq = []
#         for li in lists:
#             while li:
#                 hq.heappush(pq, li.val)
#                 li = li.next
        
#         head = ListNode()
#         dummy = head
#         for i in range(len(pq)):
#             val = hq.heappop(pq)
#             new_node = ListNode(val)
#             head.next = new_node
#             head = head.next
        
#         return dummy.next

# #second attempt logic after looking at the solution
# import heapq as hq
# class NodeWrapper:
#     def __init__(self, node):
#         self.node = node
#     # TypeError: '<' not supported between instances of 'ListNode' and 'ListNode'
#     # Heap uses < operator so we need to write the ""dunder"" function for less than which is below
#     # __eq__(self, other): Defines equality (==).
#     # __ne__(self, other): Defines “not equal” (!=).
#     # __lt__(self, other): Less than (<).
#     # __le__(self, other): Less than or equal (<=).
#     # __gt__(self, other): Greater than (>).
#     # __ge__(self, other): Greater or equal (>=).
#     def __lt__(self, other):
#         #heap is comparing NodeWrappers since that is what is being stored
#         return self.node.val < other.node.val

# class Solution:    
#     def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
#         pq = []
#         for li in lists:
#             while li:
#                 hq.heappush(pq, NodeWrapper(li))
#                 li = li.next
        
#         head = ListNode()
#         dummy = head
#         for i in range(len(pq)):
#             new_node = hq.heappop(pq).node #popping off node wrapper thus convert to node
#             head.next = new_node
#             head = head.next
        
#         return dummy.next

        



#third attempt logic after looking at the solution
import heapq as hq
class Solution:    
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if lists is None or len(lists) == 0:
            return None

        while len(lists) > 1:
            merged_lists = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if (i+1) < len(lists) else None
                new_list = self.mergeLists(l1, l2)
                merged_lists.append(new_list)
            lists = merged_lists
        return lists[0]
    
    def mergeLists(self, l1, l2):
        head = ListNode()
        dummy = head
        while l1 and l2:
            if l1.val < l2.val:
                head.next = l1
                l1 = l1.next
            else:
                head.next = l2
                l2 = l2.next
            head = head.next
        
        if l1:
            head.next = l1

        if l2:
            head.next = l2
        
        return dummy.next"
,Reverse Nodes in K-Group,Hard,Linked List,"Reverse Nodes in K-Group
Solved 
You are given the head of a singly linked list head and a positive integer k.

You must reverse the first k nodes in the linked list, and then reverse the next k nodes, and so on. If there are fewer than k nodes left, leave the nodes as they are.

Return the modified list after reversing the nodes in each group of k.

You are only allowed to modify the nodes' next pointers, not the values of the nodes.

Example 1:



Input: head = [1,2,3,4,5,6], k = 3

Output: [3,2,1,6,5,4]
Example 2:



Input: head = [1,2,3,4,5], k = 3

Output: [3,2,1,4,5]
Constraints:

The length of the linked list is n.
1 <= k <= n <= 100
0 <= Node.val <= 100","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        count = 0
    
        def reverse(prev, head, k): # reverse linked list 2
            dummy = ListNode(0, head)
            curr = head

            l_prev = None
            count = 0
            while curr and count < k:
                next = curr.next
                curr.next = l_prev
                l_prev = curr
                curr = next
                count += 1
            if prev != None:
                prev.next = l_prev
            else:
                dummy.next = l_prev
            head.next = curr
            return dummy.next, head
        
        def can_reverse(head, k):
            count = 0
            while head and count < k:
                head = head.next
                count += 1

            if count == k:
                return True
            return False
        
        curr = head
        start = head
        count = 0

        boolf = can_reverse(curr, k)
        prev = None
        while boolf:
            # print(f""top of loop, prev: {None if prev == None else prev.val}, curr: {curr.val}"")
            curr, tail = reverse(prev, curr, k)
            # print(f""curr: {curr.val}, tail: {tail}"")
            if count == 0:
                start = curr

            prev = tail
            curr = tail.next
            # print(f""curr: {curr.val}, k: {k}"")
            boolf = can_reverse(curr, k)
            count += 1
            # print(f""boolf: {boolf}"")
        
        return start
            "
,Binary Tree Inorder Traversal,Easy,Trees,"Binary Tree Inorder Traversal
Solved
Easy
Topics
premium lock icon
Companies
Given the root of a binary tree, return the inorder traversal of its nodes' values.

 

Example 1:

Input: root = [1,null,2,3]

Output: [1,3,2]

Explanation:



Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]

Output: [4,2,6,5,7,1,3,9,8]

Explanation:



Example 3:

Input: root = []

Output: []

Example 4:

Input: root = [1]

Output: [1]

 

Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def rec(root):
            if root is None:
                return
            rec(root.left)
            res.append(root.val)
            rec(root.right)

        rec(root)
        return res
        "
,Binary Tree Preorder Traversal,Easy,Trees,"Binary Tree Preorder Traversal
Solved
Easy
Topics
premium lock icon
Companies
Given the root of a binary tree, return the preorder traversal of its nodes' values.

 

Example 1:

Input: root = [1,null,2,3]

Output: [1,2,3]

Explanation:



Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]

Output: [1,2,4,5,6,7,3,8,9]

Explanation:



Example 3:

Input: root = []

Output: []

Example 4:

Input: root = [1]

Output: [1]

 

Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def rec(root):
            if root is None:
                return
            res.append(root.val)
            rec(root.left)
            rec(root.right)
            return
        
        rec(root)
        return res"
,Binary Tree Postorder Traversal,Easy,Trees,"Binary Tree Postorder Traversal
Solved
Easy
Topics
premium lock icon
Companies
Given the root of a binary tree, return the postorder traversal of its nodes' values.

 

Example 1:

Input: root = [1,null,2,3]

Output: [3,2,1]

Explanation:



Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]

Output: [4,6,7,5,2,9,8,3,1]

Explanation:



Example 3:

Input: root = []

Output: []

Example 4:

Input: root = [1]

Output: [1]

 

Constraints:

The number of the nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def rec(root):
            if root is None:
                return
            rec(root.left)
            rec(root.right)
            res.append(root.val)
            return
            
        rec(root)
        return res"
,Invert Binary Tree,Easy,Trees,"Invert Binary Tree
Solved 
You are given the root of a binary tree root. Invert the binary tree and return its root.

Example 1:



Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
Example 2:



Input: root = [3,2,1]

Output: [3,1,2]
Example 3:

Input: root = []

Output: []
Constraints:

0 <= The number of nodes in the tree <= 100.
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(root):
            if root is None:
                return
            temp = root.left
            root.left = root.right
            root.right = temp

            dfs(root.left)
            dfs(root.right)
        
        dfs(root)
        
        return root
        "
,Maximum Depth of Binary Tree,Easy,Trees,"Maximum Depth of Binary Tree
Solved 
Given the root of a binary tree, return its depth.

The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:



Input: root = [1,2,3,null,null,4]

Output: 3
Example 2:

Input: root = []

Output: 0
Constraints:

0 <= The number of nodes in the tree <= 100.
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def dfs(root):
            if root is None:
                return 0
            
            left_depth = dfs(root.left)
            right_depth = dfs(root.right)

            return max(left_depth, right_depth) + 1
        
        return dfs(root)"
,Diameter of Binary Tree,Easy,Trees,"Diameter of Binary Tree
Solved 
The diameter of a binary tree is defined as the length of the longest path between any two nodes within the tree. The path does not necessarily have to pass through the root.

The length of a path between two nodes in a binary tree is the number of edges between the nodes. Note that the path can not include the same node twice.

Given the root of a binary tree root, return the diameter of the tree.

Example 1:



Input: root = [1,null,2,3,4,5]

Output: 3
Explanation: 3 is the length of the path [1,2,3,5] or [5,3,2,4].

Example 2:

Input: root = [1,2,3]

Output: 2
Constraints:

1 <= number of nodes in the tree <= 100
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.res = 0
        
        def max_depth(root):
            if root is None:
                return 0
            
            left_depth = max_depth(root.left)
            right_depth = max_depth(root.right)

            self.res = max(self.res, left_depth + right_depth)

            return max(left_depth, right_depth) + 1
        
        if root is None:
            return 0

        max_depth(root)

        return self.res


            "
,Balanced Binary Tree,Easy,Trees,"Balanced Binary Tree
Solved 
Given a binary tree, return true if it is height-balanced and false otherwise.

A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Example 1:



Input: root = [1,2,3,null,null,4]

Output: true
Example 2:



Input: root = [1,2,3,null,null,4,null,5]

Output: false
Example 3:

Input: root = []

Output: true","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        self.res = True

        def dfs_height(root):
            if root is None:
                return 0

            l_depth = dfs_height(root.left)
            r_depth = dfs_height(root.right)

            if abs(l_depth - r_depth) > 1:
                self.res = False

            return max(l_depth, r_depth) + 1
        
        dfs_height(root)

        return self.res

        "
,Same Binary Tree,Easy,Trees,"Same Binary Tree
Solved 
Given the roots of two binary trees p and q, return true if the trees are equivalent, otherwise return false.

Two binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.

Example 1:



Input: p = [1,2,3], q = [1,2,3]

Output: true
Example 2:



Input: p = [4,7], q = [4,null,7]

Output: false
Example 3:



Input: p = [1,2,3], q = [1,3,2]

Output: false
Constraints:

0 <= The number of nodes in both trees <= 100.
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:

        def dfs_helper(root1, root2):
            if (root1 is None and root2 is not None) or (root2 is None and root1 is not None):
                return False

            if root1 is None and root2 is None:
                return True
            
            if root1.val != root2.val:
                return False
            
            l = dfs_helper(root1.left, root2.left)
            r = dfs_helper(root1.right, root2.right)

            return l and r
        
        return dfs_helper(p, q)
            

        "
,Subtree of Another Tree,Easy,Trees,"Subtree of Another Tree
Solved 
Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.

Example 1:



Input: root = [1,2,3,4,5], subRoot = [2,4,5]

Output: true
Example 2:



Input: root = [1,2,3,4,5,null,null,6], subRoot = [2,4,5]

Output: false
Constraints:

0 <= The number of nodes in both trees <= 100.
-100 <= root.val, subRoot.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:   
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        self.res = False

        def dfs_helper(root1, root2):
            if root1 is None and root2 is None:
                return True
            
            if root1 is None or root2 is None:
                return False
            
            if root1.val != root2.val:
                return False
            
            l = dfs_helper(root1.left, root2.left)
            r = dfs_helper(root1.right, root2.right)

            return l and r
        
        def dfs_transverse_root(root1, root2):
            if root1 is None:
                return
            
            if root1.val == root2.val and self.res != True:
                self.res = self.res or dfs_helper(root1, root2)
            
            if self.res != True:
                dfs_transverse_root(root1.left, root2)
                dfs_transverse_root(root1.right, root2)
            
            return
        
        dfs_transverse_root(root, subRoot)

        return self.res

        "
,Lowest Common Ancestor in Binary Search Tree,Medium,Trees,"Lowest Common Ancestor in Binary Search Tree
Solved 
Given a binary search tree (BST) where all node values are unique, and two nodes from the tree p and q, return the lowest common ancestor (LCA) of the two nodes.

The lowest common ancestor between two nodes p and q is the lowest node in a tree T such that both p and q as descendants. The ancestor is allowed to be a descendant of itself.

Example 1:



Input: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8

Output: 5
Example 2:



Input: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 4

Output: 3
Explanation: The LCA of nodes 3 and 4 is 3, since a node can be a descendant of itself.

Constraints:

2 <= The number of nodes in the tree <= 100.
-100 <= Node.val <= 100
p != q
p and q will both exist in the BST.","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        self.res = root

        def dfs_depth(root, p, q):
            if root is None:
                return False

            l = dfs_depth(root.left, p, q)
            r = dfs_depth(root.right, p, q)

            if l and r:
                self.res = root

            if root.val == p.val or root.val == q.val:
                if l or r:
                    self.res = root    
                return True
            
            return l or r
                

        dfs_depth(root, p, q)

        return self.res


# class Solution:
#     def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
#         res = root

#         while res:
#             if p.val > res.val and q.val > res.val:
#                 res = res.right
#             elif p.val < res.val and q.val < res.val:
#                 res = res.left
#             else:
#                 return res

        

#         return res
        "
,Insert into a Binary Search Tree,Medium,Trees,"Insert into a Binary Search Tree
Solved
Medium
Topics
premium lock icon
Companies
You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

 

Example 1:


Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:

Example 2:

Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]
Example 3:

Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]
 

Constraints:

The number of nodes in the tree will be in the range [0, 104].
-108 <= Node.val <= 108
All the values Node.val are unique.
-108 <= val <= 108
It's guaranteed that val does not exist in the original BST.","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        def rec(root):
            if root is None:
                return TreeNode(val = val)
            
            if root.val > val:
                root.left = rec(root.left)
            elif root.val < val:
                root.right = rec(root.right)
            
            return root
        
        return rec(root)
            "
,Delete Node in a BST,Medium,Trees,"Delete Node in a BST
Solved
Medium
Topics
premium lock icon
Companies
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.
 

Example 1:


Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

Example 2:

Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
Example 3:

Input: root = [], key = 0
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-105 <= Node.val <= 105
Each node has a unique value.
root is a valid binary search tree.
-105 <= key <= 105","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right


# class Solution:
#     def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
#         def rec(root, key):
#             if root is None:
#                 return None
#             if root.val == key:
#                 if root.left is None:
#                     return root.right
#                 elif root.right is None:
#                     return root.left
#                 elif root.left and root.right:
#                     # Case 3: Two children
#                     temp = root.left
#                     while temp.right:
#                         temp = temp.right
#                     root.val = temp.val
#                     root.left = rec(root.left, temp.val)
#                 else:
#                     return None
            
#             if root.val > key:
#                 rec(root.left, key)
#             elif root.val < key:
#                 rec(root.right, key)
            
#             return root
        
#         return rec(root, key)



class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        def rec(node, key):
            if node is None:
                return None
            
            if key < node.val:
                node.left = rec(node.left, key)
            elif key > node.val:
                node.right = rec(node.right, key)
            else:
                #key = node thus delete
                if node.left is None:
                    return node.right
                elif node.right is None:
                    return node.left
                elif node.right is None and node.left is None:
                    return None
                else:
                    #both left and right subtrees exist
                    #find either left most value on right subtree
                    #or right most value on left subtree
                    # replace the value of our node with that value and then delete that node in the subtree

                    # go to right subtree
                    curr = node.right
                    #find smalles value
                    while curr.left:
                        curr = curr.left
                    # replace nodes value with smallest right subtree value
                    val = curr.val
                    node.val = val
                    node.right = rec(node.right, val)

                    # delete the replaced value in right subtree
            return node


        return rec(root, key)"
,Binary Tree Level Order Traversal,Medium,Trees,"Binary Tree Level Order Traversal
Solved 
Given a binary tree root, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.

Example 1:



Input: root = [1,2,3,4,5,6,7]

Output: [[1],[2,3],[4,5,6,7]]
Example 2:

Input: root = [1]

Output: [[1]]
Example 3:

Input: root = []

Output: []
Constraints:

0 <= The number of nodes in the tree <= 1000.
-1000 <= Node.val <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []

        result = []
        q = [root]

        while q:
            level_size = len(q)
            level = []
            for i in range(level_size):
                curr = q.pop(0)
                level.append(curr.val)
                if curr.left:
                    q.append(curr.left)
                if curr.right:
                    q.append(curr.right)
            result.append(level[:])
        
        return result

        "
,Binary Tree Right Side View,Medium,Trees,"Binary Tree Right Side View
Solved 
You are given the root of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.

Example 1:



Input: root = [1,2,3]

Output: [1,3]
Example 2:



Input: root = [1,2,3,4,5,6,7]

Output: [1,3,7]
Constraints:

0 <= number of nodes in the tree <= 100
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        
        q = [root]
        result = []

        while q:
            level_size = len(q)
            result.append(q[-1].val)

            for i in range(level_size):
                curr = q.pop(0)

                if curr.left:
                    q.append(curr.left)
                
                if curr.right:
                    q.append(curr.right)
            
        return result

         
         "
,Construct Quad Tree,Medium,Trees,"Construct Quad Tree
Solved
Medium
Topics
premium lock icon
Companies
Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.

Return the root of the Quad-Tree representing grid.

A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:

val: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.
isLeaf: True if the node is a leaf node on the tree or False if the node has four children.
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
We can construct a Quad-Tree from a two-dimensional area using the following steps:

If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.
If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.
Recurse for each of the children with the proper sub-grid.

If you want to know more about the Quad-Tree, you can refer to the wiki.

Quad-Tree format:

You don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.

It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].

If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.

 

Example 1:


Input: grid = [[0,1],[1,0]]
Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]
Explanation: The explanation of this example is shown below:
Notice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.

Example 2:



Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
Explanation: All values in the grid are not the same. We divide the grid into four sub-grids.
The topLeft, bottomLeft and bottomRight each has the same value.
The topRight have different values so we divide it into 4 sub-grids where each has the same value.
Explanation is shown in the photo below:

 

Constraints:

n == grid.length == grid[i].length
n == 2x where 0 <= x <= 6","""""""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
""""""

class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        def helper(row_origin, col_origin, side_len):
            val = grid[row_origin][col_origin]

            if is_single_value(row_origin, col_origin, side_len):
                return Node(val = val, isLeaf = True)
            
            root = Node(val = 0, isLeaf = False)
            tl, tr, bl, br = get_new_origin_points(row_origin, col_origin, side_len)

            root.topLeft = helper(tl[0], tl[1], side_len//2)
            root.topRight = helper(tr[0], tr[1], side_len//2)
            root.bottomLeft = helper(bl[0], bl[1], side_len//2)
            root.bottomRight = helper(br[0], br[1], side_len//2)

            return root
                
        
        def is_single_value(row_origin, col_origin, side_len):
            count = 0
            for i in range(row_origin, row_origin + side_len):
                for j in range(col_origin, col_origin + side_len):
                    count += grid[i][j]

            return True if (count == 0) or (count == side_len**2) else False

        def get_new_origin_points(row_origin, col_origin, side_len):
            half_side_len = side_len // 2

            top_left = (row_origin, col_origin)
            top_right = (row_origin, col_origin + half_side_len)
            bottom_left = (row_origin + half_side_len, col_origin)
            bottom_right = (row_origin + half_side_len, col_origin + half_side_len)
            return  (top_left, top_right, bottom_left, bottom_right)
        
        return helper(0, 0, len(grid))"
,Count Good Nodes in Binary Tree,Medium,Trees,"Count Good Nodes in Binary Tree
Solved 
Within a binary tree, a node x is considered good if the path from the root of the tree to the node x contains no nodes with a value greater than the value of node x

Given the root of a binary tree root, return the number of good nodes within the tree.

Example 1:



Input: root = [2,1,1,3,null,1,5]

Output: 3


Example 2:

Input: root = [1,2,-1,3,4]

Output: 4
Constraints:

1 <= number of nodes in the tree <= 100
-100 <= Node.val <= 100","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def goodNodes(self, root: TreeNode) -> int:

        def dfs_helper(root, max_val):
            if root is None:
                return 0

            max_val = max(max_val, root.val)

            l = dfs_helper(root.left, max_val)
            r = dfs_helper(root.right, max_val)


            if root.val >= max_val:
                return l + r + 1
            return l + r
        
        return dfs_helper(root, root.val) 


            #    2
            # n     4
            #    10    8
            #         4"
,Valid Binary Search Tree,Medium,Trees,"Valid Binary Search Tree
Solved 
Given the root of a binary tree, return true if it is a valid binary search tree, otherwise return false.

A valid binary search tree satisfies the following constraints:

The left subtree of every node contains only nodes with keys less than the node's key.
The right subtree of every node contains only nodes with keys greater than the node's key.
Both the left and right subtrees are also binary search trees.
Example 1:



Input: root = [2,1,3]

Output: true
Example 2:



Input: root = [1,2,3]

Output: false
Explanation: The root node's value is 1 but its left child's value is 2 which is greater than 1.

Constraints:

1 <= The number of nodes in the tree <= 1000.
-1000 <= Node.val <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:

        def dfs_search(root, left, right):
            if root is None:
                return True
            if root.val <= left or root.val >= right:
                return False
            
            l = dfs_search(root.left, left, root.val)
            r = dfs_search(root.right, root.val, right)

            return l and r
        
        return dfs_search(root, -100000, 100000)

            

        "
,Kth Smallest Integer in BST,Medium,Trees,"Kth Smallest Integer in BST
Solved 
Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) in the tree.

A binary search tree satisfies the following constraints:

The left subtree of every node contains only nodes with keys less than the node's key.
The right subtree of every node contains only nodes with keys greater than the node's key.
Both the left and right subtrees are also binary search trees.
Example 1:



Input: root = [2,1,3], k = 1

Output: 1
Example 2:



Input: root = [4,3,5,2,null], k = 4

Output: 5
Constraints:

1 <= k <= The number of nodes in the tree <= 1000.
0 <= Node.val <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.count = 0
        self.res = -100000

        def dfs_search(root, k):
            if root is None:
                return 
            
            l = dfs_search(root.left, k)
            self.count += 1
            if self.count == k and self.res == -100000:
                self.res = root.val
            r = dfs_search(root.right, k)
        
        dfs_search(root, k)
        return self.res
        "
,Construct Binary Tree from Preorder and Inorder Traversal,Medium,Trees,"Construct Binary Tree from Preorder and Inorder Traversal
Solved 
You are given two integer arrays preorder and inorder.

preorder is the preorder traversal of a binary tree
inorder is the inorder traversal of the same tree
Both arrays are of the same size and consist of unique values.
Rebuild the binary tree from the preorder and inorder traversals and return its root.

Example 1:



Input: preorder = [1,2,3,4], inorder = [2,1,3,4]

Output: [1,2,3,null,null,null,4]
Example 2:

Input: preorder = [1], inorder = [1]

Output: [1]
Constraints:

1 <= inorder.length <= 1000.
inorder.length == preorder.length
-1000 <= preorder[i], inorder[i] <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.preorder_idx = 0
        
        def dfs_build(preorder, inorder):
            if inorder == [] or self.preorder_idx >= len(preorder):
                return None
            
            preorder_val = preorder[self.preorder_idx]
            inorder_idx = inorder.index(preorder_val) if preorder_val in inorder else None
            if inorder_idx is None:
                return None

            root = TreeNode(preorder_val)
            left_subtree = inorder[:inorder_idx]
            right_subtree = inorder[inorder_idx+1:]
            self.preorder_idx += 1
            root.left = dfs_build( preorder, left_subtree)
            root.right = dfs_build(preorder, right_subtree)

            return root
        
        return dfs_build(preorder, inorder)
        "
,House Robber III,Medium,Trees,"House Robber III
Solved
Medium
Topics
premium lock icon
Companies
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.

Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.

Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.

 

Example 1:


Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:


Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
0 <= Node.val <= 104","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        memo = {}
        def rec(node, if_can_steal):
            if node is None:
                return 0
            if (node, if_can_steal) in memo:
                return memo[(node, if_can_steal)]
            
            #take node if possible

            right_path = rec(node.right, True)
            left_path = rec(node.left, True)
            if if_can_steal == True:
                steal_right_path = rec(node.right, False)
                steal_left_path = rec(node.left, False)

                memo[(node, if_can_steal)] = max(right_path + left_path, steal_left_path + steal_right_path + node.val)

                return memo[(node, if_can_steal)]
            
            memo[(node, if_can_steal)] = left_path + right_path

            return memo[(node, if_can_steal)]
            # do not take node
        return rec(root, True)"
,Delete Leaves With a Given Value,Medium,Trees,"Delete Leaves With a Given Value
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given a binary tree root and an integer target, delete all the leaf nodes with value target.

Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).

 

Example 1:



Input: root = [1,2,3,2,null,2,4], target = 2
Output: [1,null,3,null,4]
Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).
Example 2:



Input: root = [1,3,3,3,2], target = 3
Output: [1,3,null,null,2]
Example 3:



Input: root = [1,2,null,2,null,2], target = 2
Output: [1]
Explanation: Leaf nodes in green with value (target = 2) are removed at each step.
 

Constraints:

The number of nodes in the tree is in the range [1, 3000].
1 <= Node.val, target <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        def rec(node, val):
            if node is None:
                return None
            
            
            node.left = rec(node.left, val)
            node.right = rec(node.right, val)

            if node.val == val and node.left is None and node.right is None:
                return None

            return node
        
        return rec(root, target)"
,Binary Tree Maximum Path Sum,Hard,Trees,"Binary Tree Maximum Path Sum
Solved 
Given the root of a non-empty binary tree, return the maximum path sum of any non-empty path.

A path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can not appear in the sequence more than once. The path does not necessarily need to include the root.

The path sum of a path is the sum of the node's values in the path.

Example 1:



Input: root = [1,2,3]

Output: 6
Explanation: The path is 2 -> 1 -> 3 with a sum of 2 + 1 + 3 = 6.

Example 2:



Input: root = [-15,10,20,null,null,15,5,-5]

Output: 40
Explanation: The path is 15 -> 20 -> 5 with a sum of 15 + 20 + 5 = 40.

Constraints:

1 <= The number of nodes in the tree <= 1000.
-1000 <= Node.val <= 1000","# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.res = -1000000
        
        def dfs_max_sum(root):
            if root is None:
                return 0
            
            l = dfs_max_sum(root.left)
            r = dfs_max_sum(root.right)

            self.res = max(self.res, l+r+root.val, root.val + max(l, r, 0))

            return root.val + max(l, r, 0)
        
        dfs_max_sum(root)
        return self.res
        "
,Kth Largest Element in a Stream,Easy,Heap / Priority Queue,"Kth Largest Element in a Stream
Solved 
Design a class to find the kth largest integer in a stream of values, including duplicates. E.g. the 2nd largest from [1, 2, 3, 3] is 3. The stream is not necessarily sorted.

Implement the following methods:

constructor(int k, int[] nums) Initializes the object given an integer k and the stream of integers nums.
int add(int val) Adds the integer val to the stream and returns the kth largest integer in the stream.
Example 1:

Input:
[""KthLargest"", [3, [1, 2, 3, 3]], ""add"", [3], ""add"", [5], ""add"", [6], ""add"", [7], ""add"", [8]]

Output:
[null, 3, 3, 3, 5, 6]

Explanation:
KthLargest kthLargest = new KthLargest(3, [1, 2, 3, 3]);
kthLargest.add(3);   // return 3
kthLargest.add(5);   // return 3
kthLargest.add(6);   // return 3
kthLargest.add(7);   // return 5
kthLargest.add(8);   // return 6
Constraints:

1 <= k <= 1000
0 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
-1000 <= val <= 1000
There will always be at least k integers in the stream when you search for the kth integer.","import heapq as hq 

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.nums = nums
        self.pq = []
        for num in nums:
            hq.heappush(self.pq, num)
        
        while len(self.pq) > self.k:
            hq.heappop(self.pq)
        

    def add(self, val: int) -> int:
        hq.heappush(self.pq, val)
        if len(self.pq) > self.k:
            hq.heappop(self.pq)
        return self.pq[0]"
,Last Stone Weight,Easy,Heap / Priority Queue,"Last Stone Weight
Solved 
You are given an array of integers stones where stones[i] represents the weight of the ith stone.

We want to run a simulation on the stones as follows:

At each step we choose the two heaviest stones, with weight x and y and smash them togethers
If x == y, both stones are destroyed
If x < y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
Continue the simulation until there is no more than one stone remaining.

Return the weight of the last remaining stone or return 0 if none remain.

Example 1:

Input: stones = [2,3,6,2,4]

Output: 1
Explanation:
We smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2].
We smash 3 and 2 and are left with a 1, so the array becomes [1,2,2].
We smash 2 and 2, so the array becomes [1].

Example 2:

Input: stones = [1,2]

Output: 1
Constraints:

1 <= stones.length <= 20
1 <= stones[i] <= 100","import heapq as hq
# class Solution:
#     def lastStoneWeight(self, stones: List[int]) -> int:
#         if len(stones) == 0:
#             return 0
#         elif len(stones) == 1:
#             return stones[0]
#         hq._heapify_max(stones)
#         pq = stones
#         print(f""pq: {pq}"")

#         while len(pq) > 1:
#             x = hq._heappop_max(pq)
#             y = hq._heappop_max(pq)

#             print(f""x: {x}, y: {y}"")

#             val = abs(y-x)
#             if val == 0:
#                 continue
#             hq.heappush(pq, val)
#             hq._heapify_max(pq) 
#         return pq[0] if len(pq) > 0 else 0
            
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-s for s in stones]
        heapq.heapify(stones)

        while len(stones) > 1:
            first = heapq.heappop(stones)
            second = heapq.heappop(stones)
            if second > first:
                heapq.heappush(stones, first - second)

        stones.append(0)
        return abs(stones[0])"
,K Closest Points to Origin,Easy,Heap / Priority Queue,"K Closest Points to Origin
Solved 
You are given an 2-D array points where points[i] = [xi, yi] represents the coordinates of a point on an X-Y axis plane. You are also given an integer k.

Return the k closest points to the origin (0, 0).

The distance between two points is defined as the Euclidean distance (sqrt((x1 - x2)^2 + (y1 - y2)^2)).

You may return the answer in any order.

Example 1:



Input: points = [[0,2],[2,2]], k = 1

Output: [[0,2]]
Explanation : The distance between (0, 2) and the origin (0, 0) is 2. The distance between (2, 2) and the origin is sqrt(2^2 + 2^2) = 2.82842. So the closest point to the origin is (0, 2).

Example 2:

Input: points = [[0,2],[2,0],[2,2]], k = 2

Output: [[0,2],[2,0]]
Explanation: The output [2,0],[0,2] would also be accepted.

Constraints:

1 <= k <= points.length <= 1000
-100 <= points[i][0], points[i][1] <= 100","import heapq as hq
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        
        def euclidian_distance(point_1):
            return ((point_1[0] - 0)**2 + (point_1[1] - 0)**2)**(1/2)
        
        pq = []

        for point in points:
            hq.heappush(pq, (euclidian_distance(point), point))
        
        ans = []
        for i in range(k):
            dis, point = hq.heappop(pq)
            ans.append(point)
        return ans"
,Kth Largest Element in an Array,Medium,Heap / Priority Queue,"Kth Largest Element in an Array
Solved 
Given an unsorted array of integers nums and an integer k, return the kth largest element in the array.

By kth largest element, we mean the kth largest element in the sorted order, not the kth distinct element.

Follow-up: Can you solve it without sorting?

Example 1:

Input: nums = [2,3,1,5,4], k = 2

Output: 4
Example 2:

Input: nums = [2,3,1,1,5,5,4], k = 3

Output: 4
Constraints:

1 <= k <= nums.length <= 10000
-1000 <= nums[i] <= 1000","import heapq as hq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        
        hq.heapify(nums)
        pq = nums

        while len(pq) > k:
            hq.heappop(pq)
        
        return hq.heappop(pq)"
,Task Scheduler,Medium,Heap / Priority Queue,"Task Scheduler
Solved 
You are given an array of CPU tasks tasks, where tasks[i] is an uppercase english character from A to Z. You are also given an integer n.

Each CPU cycle allows the completion of a single task, and tasks may be completed in any order.

The only constraint is that identical tasks must be separated by at least n CPU cycles, to cooldown the CPU.

Return the minimum number of CPU cycles required to complete all tasks.

Example 1:

Input: tasks = [""X"",""X"",""Y"",""Y""], n = 2

Output: 5
Explanation: A possible sequence is: X -> Y -> idle -> X -> Y.

Example 2:

Input: tasks = [""A"",""A"",""A"",""B"",""C""], n = 3

Output: 9
Explanation: A possible sequence is: A -> B -> C -> Idle -> A -> Idle -> Idle -> Idle -> A.

Constraints:

1 <= tasks.length <= 1000
0 <= n <= 100","import heapq as hq

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        queue = []
        h = []

        time = 0

        dic = defaultdict(int)
        for task in tasks:
            dic[task] += 1
        
        count = list(dic.values())
        count.sort(reverse=True)

        for c in count:
            hq.heappush(h, (-c, time))
        
        
        while h != [] or queue != []:
            # print(f""start: h: {h}, queue: {queue}"")
            if h != []:
                task_remaining, time_task_should_finish = hq.heappop(h)

                if time >= time_task_should_finish:
                    new_task_remaining = task_remaining+1
                    if new_task_remaining < 0:

                        queue.append((new_task_remaining, time+n+1))
            
            

            time += 1
            if queue != [] and queue[0][1] == time:
                hq.heappush(h, queue.pop(0))
            # print(f""end: h: {h}, queue: {queue}"")
        
        return time"
,Design Twitter,Medium,Heap / Priority Queue,"Design Twitter
Solved 
Implement a simplified version of Twitter which allows users to post tweets, follow/unfollow each other, and view the 10 most recent tweets within their own news feed.

Users and tweets are uniquely identified by their IDs (integers).

Implement the following methods:

Twitter() Initializes the twitter object.
void postTweet(int userId, int tweetId) Publish a new tweet with ID tweetId by the user userId. You may assume that each tweetId is unique.
List<Integer> getNewsFeed(int userId) Fetches at most the 10 most recent tweet IDs in the user's news feed. Each item must be posted by users who the user is following or by the user themself. Tweets IDs should be ordered from most recent to least recent.
void follow(int followerId, int followeeId) The user with ID followerId follows the user with ID followeeId.
void unfollow(int followerId, int followeeId) The user with ID followerId unfollows the user with ID followeeId.
Example 1:

Input:
[""Twitter"", ""postTweet"", [1, 10], ""postTweet"", [2, 20], ""getNewsFeed"", [1], ""getNewsFeed"", [2], ""follow"", [1, 2], ""getNewsFeed"", [1], ""getNewsFeed"", [2], ""unfollow"", [1, 2], ""getNewsFeed"", [1]]

Output:
[null, null, null, [10], [20], null, [20, 10], [20], null, [10]]

Explanation:
Twitter twitter = new Twitter();
twitter.postTweet(1, 10); // User 1 posts a new tweet with id = 10.
twitter.postTweet(2, 20); // User 2 posts a new tweet with id = 20.
twitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].
twitter.getNewsFeed(2);   // User 2's news feed should only contain their own tweets -> [20].
twitter.follow(1, 2);     // User 1 follows user 2.
twitter.getNewsFeed(1);   // User 1's news feed should contain both tweets from user 1 and user 2 -> [20, 10].
twitter.getNewsFeed(2);   // User 2's news feed should still only contain their own tweets -> [20].
twitter.unfollow(1, 2);   // User 1 follows user 2.
twitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].
Constraints:

1 <= userId, followerId, followeeId <= 100
0 <= tweetId <= 1000","import heapq as hq
class Twitter:

    def __init__(self):
        self.count = 0
        self.tweetsMap = defaultdict(list)
        self.followMap = defaultdict(set)
        

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweetsMap[userId].append((self.count, tweetId))
        self.count -= 1
        

    def getNewsFeed(self, userId: int) -> List[int]:
        pq = []
        print(f""self.followMap[userId]: {self.followMap[userId]}"")
        self.followMap[userId].add(userId)
        for followee in self.followMap[userId]:
            print(f""self.tweetsMap[followee]: {self.tweetsMap[followee]}"")
            tweet_count = 0
            for i in range(len(self.tweetsMap[followee])-1,-1,-1):
                print(f""adding tqeet to pq"")
                if tweet_count >= 10:
                    print(f""broke out"")
                    break
                print(f""adding tqeet to pq: {self.tweetsMap[followee][i]}"")
                hq.heappush(pq, self.tweetsMap[followee][i])
                tweet_count += 1
        
        print(f""pq: {pq}"")
        pop_count = 0
        res = []
        while len(pq) > 0 and pop_count < 10:
            print(f""in while res: {res}"")
            val = hq.heappop(pq)
            print(f""val: {val}"")
            res.append(val[1])
            pop_count += 1
        print(f""out while res: {res}"")
        return res

    # def getNewsFeed(self, userId: int) -> List[int]:
    #     res = []
    #     minHeap = []

    #     self.followMap[userId].add(userId)
    #     for followeeId in self.followMap[userId]:
    #         if followeeId in self.tweetsMap:
    #             index = len(self.tweetsMap[followeeId]) - 1
    #             count, tweetId = self.tweetsMap[followeeId][index]
    #             heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])

    #     while minHeap and len(res) < 10:
    #         count, tweetId, followeeId, index = heapq.heappop(minHeap)
    #         res.append(tweetId)
    #         if index >= 0:
    #             count, tweetId = self.tweetsMap[followeeId][index]
    #             heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])
    #     return res

    def follow(self, followerId: int, followeeId: int) -> None:
        self.followMap[followerId].add(followeeId)
        

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followeeId in self.followMap[followerId]:
            self.followMap[followerId].remove(followeeId)"
,Single-Threaded CPU,Medium,Heap / Priority Queue,"Single-Threaded CPU
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.

You have a single-threaded CPU that can process at most one task at a time and will act in the following way:

If the CPU is idle and there are no available tasks to process, the CPU remains idle.
If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.
Once a task is started, the CPU will process the entire task without stopping.
The CPU can finish a task then start a new one instantly.
Return the order in which the CPU will process the tasks.

 

Example 1:

Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
Explanation: The events go as follows: 
- At time = 1, task 0 is available to process. Available tasks = {0}.
- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
- At time = 2, task 1 is available to process. Available tasks = {1}.
- At time = 3, task 2 is available to process. Available tasks = {1, 2}.
- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
- At time = 4, task 3 is available to process. Available tasks = {1, 3}.
- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
- At time = 10, the CPU finishes task 1 and becomes idle.
Example 2:

Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
Output: [4,3,2,0,1]
Explanation: The events go as follows:
- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
- At time = 40, the CPU finishes task 1 and becomes idle.
 

Constraints:

tasks.length == n
1 <= n <= 105
1 <= enqueueTimei, processingTimei <= 109","import heapq as hq

# class Solution:
#     def getOrder(self, tasks: List[List[int]]) -> List[int]:
#         #(time_done, time_added, idx)
#         pq = []
#         for idx in range(len(tasks)):
#             hq.heappush(pq, (tasks[idx][0] + tasks[idx][1], tasks[idx][0], idx))
        
#         res = []
#         for i in range(len(pq)):
#             end_time, start_time, idx = hq.heappop(pq)
#             res.append(idx)
        
#         return res

# class Solution:
#     def getOrder(self, tasks: List[List[int]]) -> List[int]:
#         #(time_done, time_added, idx)
#         available_tasks = []
#         processing_task = []
#         res = []
#         graph = defaultdict(list)
#         max_time = 0
#         for i in range(len(tasks)):
#             max_time = max(max_time, tasks[i][1] + tasks[i][0])
#             graph[tasks[i][0]].append((tasks[i][1], i))
        

#         process_task_time = 0
#         for time in range(max_time+1):
#             if graph[time] != []:
#                 for processing_time, idx in graph[time]:
#                     hq.heappush(available_tasks, (processing_time, idx))
            
#             if processing_task and process_task_time <= 0:
#                 processing_time, idx = hq.heappop(processing_task)
#                 res.append(idx)
            
#             if processing_task == [] and available_tasks != []:
#                 next_task = hq.heappop(available_tasks)
#                 process_task_time = next_task[0]
#                 hq.heappush(processing_task, next_task)
            
#             process_task_time -= 1

#         if processing_task != []:
#             res.append(hq.heappop(processing_task)[1])
#         for i in range(len(available_tasks)):
#             processing_time, idx = hq.heappop(available_tasks)
#             res.append(idx)

#         return res


class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        for i, t in enumerate(tasks):
            t.append(i)
        tasks.sort(key=lambda t: t[0])

        res, minHeap = [], []
        i, time = 0, tasks[0][0]

        while minHeap or i < len(tasks):
            while i < len(tasks) and time >= tasks[i][0]:
                heapq.heappush(minHeap, [tasks[i][1], tasks[i][2]])
                i += 1
            if not minHeap:
                time = tasks[i][0]
            else:
                procTime, index = heapq.heappop(minHeap)
                time += procTime
                res.append(index)
        return res

# [
#     [19,13],  32, 19, 0
#     [16,9],   25, 16, 1
#     [21,10],  31, 21, 2
#     [32,25],  57, 32, 3
#     [37,4],   41, 37, 4
#     [49,24],  73, 49, 5
#     [2,15],   17, 2, 6
#     [38,41],  79, 38, 7
#     [37,34],  71, 37, 8
#     [33,6],   39, 33, 9
#     [45,4],   49, 45, 10
#     [18,18],  36, 18, 11
#     [46,39],  85, 46, 12
#     [12,24]]  36, 12, 13

#     17, 2, 6
#     25, 16, 1
#     31, 21, 2
#     39, 33, 9
#     41, 37, 4
#     49, 45, 10
#     32, 19, 0
#     36, 18, 11
#     73, 49, 5
#     36, 12, 13
#     57, 32, 3
#     71, 37, 8
#     85, 46, 12
#     79, 38, 7
    "
,Reorganize String,Medium,Heap / Priority Queue,"Reorganize String
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.

Return any possible rearrangement of s or return """" if not possible.

 

Example 1:

Input: s = ""aab""
Output: ""aba""
Example 2:

Input: s = ""aaab""
Output: """"
 

Constraints:

1 <= s.length <= 500
s consists of lowercase English letters.","# import heapq as hq
# class Solution:
#     def reorganizeString(self, s: str) -> str:
#         pq = []

#         dic_count = defaultdict(int)
#         for letter in s:
#             dic_count[letter] += 1

#         if max(dic_count.values()) > sum(dic_count.values()) - max(dic_count.values()) +1:
#             return """"
        

#         dic_count = dict(sorted(dic_count.items(), key=lambda item: item[1], reverse=True))
#         # print(f""dict_count"")

#         res = """"
#         while sum(dic_count.values()) > 0:
#             for new_letter in dic_count.keys():
#                 if res and new_letter == res[-1]:
#                     continue
#                 if dic_count[new_letter] <= 0:
#                     continue
#                 res += new_letter
#                 dic_count[new_letter] -= 1
#                 break
        
#         return res






import heapq as hq
class Solution:
    def reorganizeString(self, s: str) -> str:
        pq = []

        dic_count = defaultdict(int)
        for letter in s:
            dic_count[letter] += 1

        if max(dic_count.values()) > sum(dic_count.values()) - max(dic_count.values()) +1:
            return """"

        for key, value in dic_count.items():
            hq.heappush(pq, (-value, key))
        
        res = ''
        while pq:
            count, letter = hq.heappop(pq)
            if res and res[-1] == letter:
                count_2, letter_2 = hq.heappop(pq)
                res += letter_2
                nc = count_2+1
                if nc != 0:
                    hq.heappush(pq, (nc, letter_2))
                hq.heappush(pq, (count, letter))
                continue
            
            res += letter
            nc = count+1
            if nc != 0:
                hq.heappush(pq, (nc, letter))

        
        return res

# class Solution:
#     def reorganizeString(self, s: str) -> str:
#         count = Counter(s)
#         maxHeap = [[-cnt, char] for char, cnt in count.items()]
#         heapq.heapify(maxHeap)
        
#         prev = None
#         res = """"
#         while maxHeap or prev:
#             if prev and not maxHeap:
#                 return """"
            
#             cnt, char = heapq.heappop(maxHeap)
#             res += char
#             cnt += 1

#             if prev:
#                 heapq.heappush(maxHeap, prev)
#                 prev = None
            
#             if cnt != 0:
#                 prev = [cnt, char]
        
#         return res"
,Longest Happy String,Medium,Heap / Priority Queue,"Longest Happy String
Solved
Medium
Topics
premium lock icon
Companies
Hint
A string s is called happy if it satisfies the following conditions:

s only contains the letters 'a', 'b', and 'c'.
s does not contain any of ""aaa"", ""bbb"", or ""ccc"" as a substring.
s contains at most a occurrences of the letter 'a'.
s contains at most b occurrences of the letter 'b'.
s contains at most c occurrences of the letter 'c'.
Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string """".

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: a = 1, b = 1, c = 7
Output: ""ccaccbcc""
Explanation: ""ccbccacc"" would also be a correct answer.
Example 2:

Input: a = 7, b = 1, c = 0
Output: ""aabaa""
Explanation: It is the only correct answer in this case.
 

Constraints:

0 <= a, b, c <= 100
a + b + c > 0","import heapq as hq
class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        max_pq = []
        if a != 0:
            hq.heappush(max_pq, (-a, ""a""))
        if b != 0:
            hq.heappush(max_pq, (-b, ""b""))
        if c != 0:
            hq.heappush(max_pq, (-c, ""c""))
        
        res = """"
        while max_pq:
            count, letter = hq.heappop(max_pq)
            if res and len(res) >= 2 and res[-2] == res[-1] == letter and len(max_pq) <= 0:
                return res
            
            if res and len(res) >= 2 and res[-2] == res[-1] == letter:
                count2, letter2 = hq.heappop(max_pq)
                nc = count2 + 1
                res += letter2
                if nc != 0:
                    hq.heappush(max_pq, (nc, letter2))
                hq.heappush(max_pq, (count, letter))
                continue
            
            nc = count + 1
            res += letter
            if nc != 0:
                hq.heappush(max_pq, (nc, letter))

        return res
            

        "
,Car Pooling,Medium,Heap / Priority Queue,"Car Pooling
Solved
Medium
Topics
premium lock icon
Companies
Hint
There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).

You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.

Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.

 

Example 1:

Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
Example 2:

Input: trips = [[2,1,5],[3,3,7]], capacity = 5
Output: true
 

Constraints:

1 <= trips.length <= 1000
trips[i].length == 3
1 <= numPassengersi <= 100
0 <= fromi < toi <= 1000
1 <= capacity <= 105","import heapq as hq
# class Solution:
#     def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
#         for i in range(len(trips)):
#             trips[i][0], trips[i][1], trips[i][2] = trips[i][1], trips[i][2], trips[i][0]
#         # enque, de_que, capacity

#         trips.sort(key=lambda t: t[0])
#         minHeap = []
#         i = 0
#         location = trips[0][0]
#         curr_capacity = 0
#         while minHeap or i < len(trips):
#             while i < len(trips) and location <= trips[i][0]:
#                 heapq.heappush(minHeap, [trips[i][1], trips[i][2]])
#                 curr_capacity += trips[i][2]
#                 i += 1
#             if not minHeap:
#                 location = trips[i][0]
#                 curr_capacity += trips[i][2]
#                 # if curr_capacity > capacity:
#                 #     return False
#             else:
#                 drop_off, car_capacity = heapq.heappop(minHeap)
#                 curr_capacity -= car_capacity
#                 location =  drop_off
            
#             if  curr_capacity > capacity:
#                     return False
                
#         return True

class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips.sort(key=lambda t: t[1])
        
        minHeap = []  # pair of [end, numPassengers]
        curPass = 0
        
        for numPass, start, end in trips: 
                              # If the end of the smallest end trip is less than our current location
                              # that means we can remove passengers
            while minHeap and minHeap[0][0] <= start:
                curPass -= hq.heappop(minHeap)[1]
            
            # Now we need to add our passengers to the road and we need to
            # push to the heap to see when they get off the road
            
            curPass += numPass
            if curPass > capacity:
                return False
            
            hq.heappush(minHeap, [end, numPass])
        
        return True
    "
,Sum of All Subset XOR Totals,Easy,Backtracking,"Sum of All Subset XOR Totals
Solved
Easy
Topics
premium lock icon
Companies
Hint
The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

 

Example 1:

Input: nums = [1,3]
Output: 6
Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
Example 2:

Input: nums = [5,1,6]
Output: 28
Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
Example 3:

Input: nums = [3,4,5,6,7,8]
Output: 480
Explanation: The sum of all XOR totals for every subset is 480.
 

Constraints:

1 <= nums.length <= 12
1 <= nums[i] <= 20","class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0

        def xor(arr):
            result = 0
            for val in arr:
                result = result ^ val
            return result

        def combin(start, comb_arr):
            nonlocal res
            res += xor(comb_arr)

            for i in range(start, n):
                # if i > start and nums[i] == nums[i-1]:
                #     continue
                comb_arr.append(nums[i])
                combin(i+1, comb_arr)
                comb_arr.pop()
        
        combin(0, [])
        return res"
,Subsets,Medium,Backtracking,"Subsets
Solved 
Given an array nums of unique integers, return all possible subsets of nums.

The solution set must not contain duplicate subsets. You may return the solution in any order.

Example 1:

Input: nums = [1,2,3]

Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [7]

Output: [[],[7]]
Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10","class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        nums.sort()

        def rec_helper(start, path):

            self.res.append(path[:])

            for i in range(start, len(nums)):
                if i > start and nums[i] == nums[i-1]:
                    continue

                path.append(nums[i])
                rec_helper(i+1, path)
                path.pop()
        
        rec_helper(0, [])
        return self.res

        "
,Combination Sum,Medium,Backtracking,"Combination Sum
Solved 
You are given an array of distinct integers nums and a target integer target. Your task is to return a list of all unique combinations of nums where the chosen numbers sum to target.

The same number may be chosen from nums an unlimited number of times. Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.

You may return the combinations in any order and the order of the numbers in each combination can be in any order.

Example 1:

Input: 
nums = [2,5,6,9] 
target = 9

Output: [[2,2,5],[9]]
Explanation:
2 + 2 + 5 = 9. We use 2 twice, and 5 once.
9 = 9. We use 9 once.

Example 2:

Input: 
nums = [3,4,5]
target = 16

Output: [[3,3,3,3,4],[3,3,5,5],[4,4,4,4],[3,4,4,5]]
Example 3:

Input: 
nums = [3]
target = 5

Output: []
Constraints:

All elements of nums are distinct.
1 <= nums.length <= 20
2 <= nums[i] <= 30
2 <= target <= 30","class Solution:
    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:
        self.res = []

        def dfs_sum(start, path, target_points):
            if target_points < 0:
                return
            if target_points == 0:
                self.res.append(path[:])
                return
            
            for i in range(start, len(nums)):
                # if i > start and nums[i] == nums[i-1]:
                #     continue
                
                path.append(nums[i])
                target_points -= nums[i]
                dfs_sum(i, path, target_points)
                path.pop()
                target_points += nums[i]
        
        dfs_sum(0, [], target)

        return self.res
        "
,Combination Sum II,Medium,Backtracking,"Combination Sum II
Solved 
You are given an array of integers candidates, which may contain duplicates, and a target integer target. Your task is to return a list of all unique combinations of candidates where the chosen numbers sum to target.

Each element from candidates may be chosen at most once within a combination. The solution set must not contain duplicate combinations.

You may return the combinations in any order and the order of the numbers in each combination can be in any order.

Example 1:

Input: candidates = [9,2,2,4,6,1,5], target = 8

Output: [
  [1,2,5],
  [2,2,4],
  [2,6]
]
Example 2:

Input: candidates = [1,2,3,4,5], target = 7

Output: [
  [1,2,4],
  [2,5],
  [3,4]
]
Constraints:

1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30","class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res = []
        candidates.sort()

        def dfs_sum(start, path, tar):
            if tar < 0:
                return
            if tar == 0:
                self.res.append(path[:])
                return
            
            for i in range(start, len(candidates)):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                
                path.append(candidates[i])
                tar -= candidates[i]
                dfs_sum(i+1, path, tar)
                path.pop()
                tar += candidates[i]
        
        dfs_sum(0, [], target)
        return self.res"
,Combinations,Medium,Backtracking,"Combinations
Solved
Medium
Topics
premium lock icon
Companies
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.

 

Example 1:

Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
Example 2:

Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 

Constraints:

1 <= n <= 20
1 <= k <= n","class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        results = []

        def rec(start, combination_arr):
            if len(combination_arr) == k:
                results.append(combination_arr[:])
                return
            
            for i in range(start, n+1):
                # if i > start and 
                combination_arr.append(i)
                rec(i + 1, combination_arr)
                combination_arr.pop()
            
            return

        
        rec(1, [])

        return results"
,Permutations,Medium,Backtracking,"Permutations
Solved 
Given an array nums of unique integers, return all the possible permutations. You may return the answer in any order.

Example 1:

Input: nums = [1,2,3]

Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:

Input: nums = [7]

Output: [[7]]
Constraints:

1 <= nums.length <= 6
-10 <= nums[i] <= 10","class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.used = [False] * len(nums)

        def dfs_perm(path):
            if len(path) == len(nums):
                self.res.append(path[:])
                return
            
            for i in range(len(nums)):
                if self.used[i]:
                    continue
                
                # if i > 0 and nums[i] == nums[i-1] and not self.used[i-1]:
                #     continue
                    
                    
                self.used[i] = True
                path.append(nums[i])
                dfs_perm(path)
                self.used[i] = False
                path.pop()

        dfs_perm([])
        return self.res
        "
,Subsets II,Medium,Backtracking,"Subsets II
Solved 
You are given an array nums of integers, which may contain duplicates. Return all possible subsets.

The solution must not contain duplicate subsets. You may return the solution in any order.

Example 1:

Input: nums = [1,2,1]

Output: [[],[1],[1,2],[1,1],[1,2,1],[2]]
Example 2:

Input: nums = [7,7]

Output: [[],[7], [7,7]]
Constraints:

1 <= nums.length <= 11
-20 <= nums[i] <= 20","class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.used = [False] * len(nums)
        nums.sort()

        def dfs_sub(start, path):
            self.res.append(path[:])
            if len(path) > len(nums):
                return

            for i in range(start, len(nums)):
                if i > start and nums[i] == nums[i-1]:
                    continue
                
                path.append(nums[i])
                dfs_sub(i+1, path)
                path.pop()
        
        dfs_sub(0,[])
        return self.res"
,Permutations II,Medium,Backtracking,"Permutations II
Solved
Medium
Topics
premium lock icon
Companies
Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

 

Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
Example 2:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

Constraints:

1 <= nums.length <= 8
-10 <= nums[i] <= 10","class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        result = []
        used = [False] * n

        def perm(perm_arr):
            print(f""perm_arr: {perm_arr}"")
            if len(perm_arr) == n:
                result.append(perm_arr[:])
                return
            
            for i in range(n):
                if used[i]:
                    continue
                if i > 0 and nums[i] == nums[i-1] and used[i - 1] == True:
                    continue
                
                perm_arr.append(nums[i])
                used[i] = True
                perm(perm_arr)
                perm_arr.pop()
                used[i] = False
        
        perm([])
        return result
        "
,Word Search,Medium,Backtracking,"Word Search
Solved 
Given a 2-D grid of characters board and a string word, return true if the word is present in the grid, otherwise return false.

For the word to be present it must be possible to form it with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.

Example 1:



Input: 
board = [
  [""A"",""B"",""C"",""D""],
  [""S"",""A"",""A"",""T""],
  [""A"",""C"",""A"",""E""]
],
word = ""CAT""

Output: true
Example 2:



Input: 
board = [
  [""A"",""B"",""C"",""D""],
  [""S"",""A"",""A"",""T""],
  [""A"",""C"",""A"",""E""]
],
word = ""BAT""

Output: false
Constraints:

1 <= board.length, board[i].length <= 5
1 <= word.length <= 10
board and word consists of only lowercase and uppercase English letters.","class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs_find(i, j, word):
            if word == """":
                return True
            if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]):
                return False
            if board[i][j] != word[0]:
                return False
            
            word1 = word[0]
            word = word[1:]
            hold = board[i][j]
            board[i][j] = ""0""
            u = dfs_find(i + 1, j, word)
            d = dfs_find(i - 1, j, word)
            l = dfs_find(i, j + 1, word)
            r = dfs_find(i, j - 1, word)
            word = word1 + word
            board[i][j] = hold

            return u or d or l or r
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0] and dfs_find(i, j, word):
                    return True
        
        return False
            

        "
,Palindrome Partitioning,Medium,Backtracking,"Palindrome Partitioning
Solved 
Given a string s, split s into substrings where every substring is a palindrome. Return all possible lists of palindromic substrings.

You may return the solution in any order.

Example 1:

Input: s = ""aab""

Output: [[""a"",""a"",""b""],[""aa"",""b""]]
Example 2:

Input: s = ""a""

Output: [[""a""]]
Constraints:

1 <= s.length <= 20
s contains only lowercase English letters.","class Solution:
    def partition(self, s: str) -> List[List[str]]:
        self.res = []

        def is_palindrome(word):
            l = 0
            r = len(word) - 1

            while l < r:
                if word[l] != word[r]:
                    return False
                l += 1
                r -= 1
            
            return True
        
        def dfs_combination_split(path, word):
            if word == """":
                self.res.append(path[:])
                return
            
            for i in range(1, len(word)+1):
                new_word = word[:i]

                if not is_palindrome(new_word):
                    continue
                
                path.append(new_word)
                dfs_combination_split(path, word[i:])
                path.pop()
        
        dfs_combination_split([], s)
        return self.res


        "
,Letter Combinations of a Phone Number,Medium,Backtracking,"Letter Combinations of a Phone Number
Solved 
You are given a string digits made up of digits from 2 through 9 inclusive.

Each digit (not including 1) is mapped to a set of characters as shown below:

A digit could represent any one of the characters it maps to.

Return all possible letter combinations that digits could represent. You may return the answer in any order.



Example 1:

Input: digits = ""34""

Output: [""dg"",""dh"",""di"",""eg"",""eh"",""ei"",""fg"",""fh"",""fi""]
Example 2:

Input: digits = """"

Output: []
Constraints:

0 <= digits.length <= 4
2 <= digits[i] <= 9","class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if digits == """":
            return []
            
        dic = {
            ""2"": [""a"", ""b"", ""c""],
            ""3"": [""d"", ""e"", ""f""],
            ""4"": [""g"", ""h"", ""i""],
            ""5"": [""j"", ""k"", ""l""],
            ""6"": [""m"", ""n"", ""o""],
            ""7"": [""p"", ""q"", ""r"", ""s""],
            ""8"": [""t"", ""u"", ""v""],
            ""9"": [""w"", ""x"", ""y"", ""z""],
        }

        self.res = []

        def dfs(digits_string, path):
            if digits_string == """":
                self.res.append(path)
                return

            digit = digits_string[0]
            letter_set = dic[digit]
            for i in range(len(letter_set)):
                path += letter_set[i]
                dfs(digits_string[1:], path)
                path = path[:-1]
        
        dfs(digits, """")
        return self.res"
,Matchsticks to Square,Medium,Backtracking,"Matchsticks to Square
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Return true if you can make this square and false otherwise.

 

Example 1:


Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
Example 2:

Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
 

Constraints:

1 <= matchsticks.length <= 15
1 <= matchsticks[i] <= 108","# class Solution:
#     def makesquare(self, matchsticks: List[int]) -> bool:
#         #this is a combinations question
#         matchsticks.sort(reverse=True)
#         result = []
#         total_len = sum(matchsticks)

#         if total_len % 2 == 1:
#             return False

#         side_len = total_len/4
#         side_count = 0

#         def rec(start, target_side):
#             nonlocal side_len, side_count

#             if target_side == 0:
#                 side_count += 1
#                 if side_count == 4:
#                     return True
#                 target_side = side_len
            
#             if target_side < 0:
#                 return False
            
            

#             res = False
#             for i in range(start, len(matchsticks)):
#                 val = matchsticks[i]
#                 res = rec(i+1, target_side - val)
        
#             return res
        
#         return rec(0, side_len)




class Solution:
    def makesquare(self, matchsticks: List[int]) -> bool:
        #this is a combinations question
        matchsticks.sort(reverse=True)
        result = []
        total_len = sum(matchsticks)

        if total_len % 4 != 0:
            return False

        matchstick_set = [total_len / 4] * 4

        def backtrack(idx):
            #base case
            if idx == len(matchsticks):
                return True
            
            #other choices picking 1 of the 4 sides
            for i in range(4):
                if matchstick_set[i] - matchsticks[idx] >= 0:
                    matchstick_set[i] -= matchsticks[idx]
                    found_a_solution = backtrack(idx+1)
                    if found_a_solution:
                        return True
                    matchstick_set[i] += matchsticks[idx]
            
            return False
        
        return backtrack(0)"
,Partition to K Equal Sum Subsets,Medium,Backtracking,"Partition to K Equal Sum Subsets
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.

 

Example 1:

Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
Example 2:

Input: nums = [1,2,3,4], k = 3
Output: false
 

Constraints:

1 <= k <= nums.length <= 16
1 <= nums[i] <= 104
The frequency of each element is in the range [1, 4].","class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        n = len(nums)
        nums.sort(reverse=True)
        if total % k != 0:
            return False
        
        side_len = total / k
        
        subsets = [side_len] * k

        def rec(idx):
            if idx == n:
                return True
            
            for i in range(k):
                if subsets[i] - nums[idx] >= 0:
                    subsets[i] -= nums[idx]
                    found_solution = rec(idx+1)
                    if found_solution:
                        return True
                    subsets[i] += nums[idx]

                    if subsets[i] == side_len:
                        break
            return False

        return rec(0)

# class Solution:
#     def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
#         total = sum(nums)
#         n = len(nums)
#         nums.sort(reverse=True)  
#         if total % k != 0:
#             return False

#         target = total // k
#         # ""subsets[i]"" will track how much capacity is left in the i-th subset
#         subsets = [target] * k

#         # Memo to avoid repeating states:
#         # Key will be (idx, tuple(sorted_subsets))
#         #   - ""idx"" is which element in nums we are trying to place
#         #   - ""sorted_subsets"" is the sorted version of 'subsets' 
#         #     so that different permutations of the same leftover capacities
#         #     look identical in the memo
#         memo = {}

#         def backtrack(idx):
#             # If we've assigned all numbers successfully, we're done
#             if idx == n:
#                 return True

#             # Create a memo key by sorting 'subsets'
#             # Sorting ensures that e.g. [2,1,2] and [2,2,1] 
#             # are recognized as the same leftover capacities
#             key = (idx, tuple(sorted(subsets)))
#             if key in memo:
#                 return memo[key]

#             for i in range(k):
#                 # If current nums[idx] can fit in subsets[i]
#                 if subsets[i] >= nums[idx]:
#                     # Place nums[idx] in subset i
#                     subsets[i] -= nums[idx]

#                     if backtrack(idx + 1):
#                         memo[key] = True
#                         return True

#                     # Backtrack (remove nums[idx] from subset i)
#                     subsets[i] += nums[idx]

#                 # Optimization: if subsets[i] was exactly target before we tried to place nums[idx],
#                 # and we put it back to target, then no need to try the next empty bucket 
#                 # (this helps prune symmetrical states)
#                 if subsets[i] == target:
#                     break

#             memo[key] = False
#             return False

#         return backtrack(0)"
,N-Queens,Hard,Backtracking,"N-Queens
Solved 
The n-queens puzzle is the problem of placing n queens on an n x n chessboard so that no two queens can attack each other.

A queen in a chessboard can attack horizontally, vertically, and diagonally.

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a unique board layout where the queen pieces are placed. 'Q' indicates a queen and '.' indicates an empty space.

You may return the answer in any order.

Example 1:



Input: n = 4

Output: [["".Q.."",""...Q"",""Q..."",""..Q.""],[""..Q."",""Q..."",""...Q"","".Q..""]]
Explanation: There are two different solutions to the 4-queens puzzle.

Example 2:

Input: n = 1

Output: [[""Q""]]
Constraints:

1 <= n <= 8","class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        if n == 1:
            return [[""Q""]]
        board = [[""."" for _ in range(n)] for _ in range(n)]

        
        def is_valid(i, j):

            for col in range(j):
                if board[i][col]==""Q"":
                    return False

            row = i
            col = j
            while row >= 0 and col >= 0:
                if board[row][col]==""Q"":
                    return False
                row -= 1
                col -= 1

            row = i
            col = j
            while row < n and col >= 0:
                if board[row][col]==""Q"":
                    return False
                row += 1
                col -= 1
            

            return True


        ans = []
        def rec(col):
            nonlocal ans
            if col == n:
                ans.append(["""".join(row[:]) for row in board])
                return 


            for i in range(n):  
                if not is_valid(i, col):
                    continue
                board[i][col] = ""Q""
                rec(col+1)
                board[i][col] = "".""
            return 

        print(f""rec(0): {rec(0)}"")
        print(f""ans: {ans}"")
        return ans
            


        
        "
,N-Queens II,Hard,Backtracking,"N-Queens II
Solved
Hard
Topics
premium lock icon
Companies
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

Given an integer n, return the number of distinct solutions to the n-queens puzzle.

 

Example 1:


Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.
Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 9","class Solution:
    def totalNQueens(self, n: int) -> int:
        if n == 1:
            return 1

        board = [[""."" for _ in range(n)] for _ in range(n)]

        def is_valid(i, j):
            for col in range(j, -1, -1):
                if board[i][col] == ""Q"":
                    return False

            row = i
            col = j
            while row >= 0 and col >= 0:
                if board[row][col] == ""Q"":
                    return False
                row -= 1
                col -= 1
            
            row = i
            col = j
            while row < n and col >= 0:
                if board[row][col] == ""Q"":
                    return False
                row += 1
                col -= 1
            
            return True
        
        def rec(col):
            if col == n:
                print(f""board: {board}"")
                return 1
            count = 0
            for i in range(n):
                if not is_valid(i, col):
                    continue
                
                board[i][col] = ""Q""
                count += rec(col+1)
                board[i][col] = "".""
            
            return count
        
        return rec(0)"
,Word Break II,Hard,Backtracking,"Word Break II
Solved
Hard
Topics
premium lock icon
Companies
Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

 

Example 1:

Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
Example 2:

Input: s = ""pineapplepenapple"", wordDict = [""apple"",""pen"",""applepen"",""pine"",""pineapple""]
Output: [""pine apple pen apple"",""pineapple pen apple"",""pine applepen apple""]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: []
 

Constraints:

1 <= s.length <= 20
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 10
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Input is generated in a way that the length of the answer doesn't exceed 105.","class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        n = len(s)
        
        ans = []
        def rec(idx, path):
            if idx == n:
                ans.append("" "".join(path[:]))
                return
            
            for end in range(idx, n):
                if not in_dic(idx, end):
                    continue
                
                path.append(s[idx:end+1])
                rec(end+1, path)
                path.pop()
            
            return
            
        def in_dic(start, end):
            if s[start:end+1] in wordDict:
                return True
            return False
        
        rec(0, [])
        return ans"
,Implement Trie (Prefix Tree),Medium,Tries,"Implement Trie (Prefix Tree)
Solved 
A prefix tree (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.

Implement the PrefixTree class:

PrefixTree() Initializes the prefix tree object.
void insert(String word) Inserts the string word into the prefix tree.
boolean search(String word) Returns true if the string word is in the prefix tree (i.e., was inserted before), and false otherwise.
boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.
Example 1:

Input: 
[""Trie"", ""insert"", ""dog"", ""search"", ""dog"", ""search"", ""do"", ""startsWith"", ""do"", ""insert"", ""do"", ""search"", ""do""]

Output:
[null, null, true, false, true, null, true]

Explanation:
PrefixTree prefixTree = new PrefixTree();
prefixTree.insert(""dog"");
prefixTree.search(""dog"");    // return true
prefixTree.search(""do"");     // return false
prefixTree.startsWith(""do""); // return true
prefixTree.insert(""do"");
prefixTree.search(""do"");     // return true
Constraints:

1 <= word.length, prefix.length <= 1000
word and prefix are made up of lowercase English letters.","class Node:

    def __init__(self):
        self.children = {}
        self.endOfWord = False

class PrefixTree:

    def __init__(self):
        self.root = Node()
        

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = Node()
            cur = cur.children[c]
        cur.endOfWord = True


    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.endOfWord == True
        

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
        
        "
,Design Add and Search Word Data Structure,Medium,Tries,"Design Add and Search Word Data Structure
Solved 
Design a data structure that supports adding new words and searching for existing words.

Implement the WordDictionary class:

void addWord(word) Adds word to the data structure.
bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.
Example 1:

Input:
[""WordDictionary"", ""addWord"", ""day"", ""addWord"", ""bay"", ""addWord"", ""may"", ""search"", ""say"", ""search"", ""day"", ""search"", "".ay"", ""search"", ""b..""]

Output:
[null, null, null, null, false, true, true, true]

Explanation:
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(""day"");
wordDictionary.addWord(""bay"");
wordDictionary.addWord(""may"");
wordDictionary.search(""say""); // return false
wordDictionary.search(""day""); // return true
wordDictionary.search("".ay""); // return true
wordDictionary.search(""b..""); // return true
Constraints:

1 <= word.length <= 20
word in addWord consists of lowercase English letters.
word in search consist of '.' or lowercase English letters.
There will be at most 2 dots in word for search queries.
At most 10,000 calls will be made to addWord and search.","class Node:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class WordDictionary:

    def __init__(self):
        self.root = Node()

    def addWord(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = Node()
            cur = cur.children[c]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        def dfs(i, cur):
            for n in range(i, len(word)):
                c = word[n]
                if c == ""."":
                    for child in cur.children.values():
                        if dfs(n+1, child):
                            return True
                    return False
                else:
                    if c not in cur.children:
                        return False
                    cur = cur.children[c]
            return cur.endOfWord == True
        
        return dfs(0, self.root)
        "
,Extra Characters in a String,Medium,Tries,"Extra Characters in a String
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.

Return the minimum number of extra characters left over if you break up s optimally.

 

Example 1:

Input: s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1
Explanation: We can break s in two substrings: ""leet"" from index 0 to 3 and ""code"" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.

Example 2:

Input: s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3
Explanation: We can break s in two substrings: ""hello"" from index 3 to 7 and ""world"" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
 

Constraints:

1 <= s.length <= 50
1 <= dictionary.length <= 50
1 <= dictionary[i].length <= 50
dictionary[i] and s consists of only lowercase English letters
dictionary contains distinct words","class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        n = len(s)
        memo = {}
        def dfs(idx):
            if idx >= n:
                return 0
            if idx in memo:
                return memo[idx]
            
            curr_count = len(s)+1
            # option 1 is there a word in the dictionary take it and move fowards
            for word in dictionary:
                word_len = len(word)
                if s[idx:idx + word_len] == word:
                    curr_count =  min(curr_count, dfs(idx + word_len))

            
            # No word in the dictionary move idx plus 1
            curr_count = min(curr_count, dfs(idx + 1) + 1)

            memo[idx] = curr_count

            return curr_count
        
        
        
        return dfs(0)"
,Island Perimeter,Easy,Graphs,"Island Perimeter
Solved
Easy
Topics
premium lock icon
Companies
You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

 

Example 1:


Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Example 2:

Input: grid = [[1]]
Output: 4
Example 3:

Input: grid = [[1,0]]
Output: 4
 

Constraints:

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] is 0 or 1.
There is exactly one island in grid.","class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        row = len(grid)
        col = len(grid[0])

        def dfs(r, c):
            if r < 0 or r >= row or \
               c < 0 or c >= col or \
               grid[r][c] == 0:
               return 1
            if grid[r][c] == -1:
                return 0

            grid[r][c] = -1
            up = dfs(r - 1, c)
            down = dfs(r + 1, c)
            left = dfs(r, c - 1)
            right = dfs(r, c + 1)

            return up + down + left + right
        
        perimeter = 0
        for i in range(row):
            for j in range(col):
                if grid[i][j] == 1:
                    perimeter += dfs(i, j)
        
        return perimeter


# class Solution:
#     def islandPerimeter(self, grid: List[List[int]]) -> int:
#         rows, cols = len(grid), len(grid[0])
#         perimeter = 0
        
#         def dfs(r, c):
#             if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0:
#                 return 1
#             if grid[r][c] == -1:
#                 return 0
#             grid[r][c] = -1
#             return (dfs(r + 1, c) +
#                     dfs(r - 1, c) +
#                     dfs(r, c + 1) +
#                     dfs(r, c - 1))

#         for r in range(rows):
#             for c in range(cols):
#                 if grid[r][c] == 1:
#                     perimeter += dfs(r, c)

#         return perimeter"
,Verifying An Alien Dictionary,Easy,Graphs,"Verifying an Alien Dictionary
Solved
Easy
Topics
premium lock icon
Companies
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.

 

Example 1:

Input: words = [""hello"",""leetcode""], order = ""hlabcdefgijkmnopqrstuvwxyz""
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
Example 2:

Input: words = [""word"",""world"",""row""], order = ""worldabcefghijkmnpqstuvxyz""
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
Example 3:

Input: words = [""apple"",""app""], order = ""abcdefghijklmnopqrstuvwxyz""
Output: false
Explanation: The first three characters ""app"" match, and the second string is shorter (in size.) According to lexicographical rules ""apple"" > ""app"", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
All characters in words[i] and order are English lowercase letters.","class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        count = 1
        letter_order = {}
        for letter in order:
            letter_order[letter] = count
            count += 1
        

        for i in range(1, len(words)):
            word_1 = words[i-1]
            word_2 = words[i]
            same_beginning = True
            for j in range(min(len(word_1), len(word_2))):
                same_beginning = same_beginning and (word_1[j] == word_2[j])
                print(f""j: {j}, word_1[j]: {word_1[j]}, word_2[j]: {word_2[j]}"")
                if letter_order[word_1[j]] < letter_order[word_2[j]]:
                    break
                elif letter_order[word_1[j]] > letter_order[word_2[j]]:
                    return False

            if same_beginning and len(word_1) > len(word_2):
                return False
                
        return True
        "
,Find the Town Judge,Easy,Graphs,"Find the Town Judge
Solved
Easy
Topics
premium lock icon
Companies
In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.

Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.

 

Example 1:

Input: n = 2, trust = [[1,2]]
Output: 2
Example 2:

Input: n = 3, trust = [[1,3],[2,3]]
Output: 3
Example 3:

Input: n = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
 

Constraints:

1 <= n <= 1000
0 <= trust.length <= 104
trust[i].length == 2
All the pairs of trust are unique.
ai != bi
1 <= ai, bi <= n","class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        if n <= 1:
            return 1
        possible_ans = []
        trust_dic = defaultdict(list)
        reverse_trust_dic = defaultdict(list)
        for person, person_of_trust in trust:
            trust_dic[person_of_trust].append(person)
            reverse_trust_dic[person].append(person_of_trust)
            if len(trust_dic[person_of_trust]) == n-1:
                possible_ans.append(person_of_trust)
        
        for possible_judge in possible_ans:
            if len(reverse_trust_dic[possible_judge]) == 0:
                return possible_judge

        return -1"
,Number of Islands,Medium,Graphs,"Number of Islands
Solved 
Given a 2D grid grid where '1' represents land and '0' represents water, count and return the number of islands.

An island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).

Example 1:

Input: grid = [
    [""0"",""1"",""1"",""1"",""0""],
    [""0"",""1"",""0"",""1"",""0""],
    [""1"",""1"",""0"",""0"",""0""],
    [""0"",""0"",""0"",""0"",""0""]
  ]
Output: 1
Example 2:

Input: grid = [
    [""1"",""1"",""0"",""0"",""1""],
    [""1"",""1"",""0"",""0"",""1""],
    [""0"",""0"",""1"",""0"",""0""],
    [""0"",""0"",""0"",""1"",""1""]
  ]
Output: 4
Constraints:

1 <= grid.length, grid[i].length <= 100
grid[i][j] is '0' or '1'.","class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        self.n = len(grid)
        self.m = len(grid[0])

        def dfs_remove_island(i, j):
            if i < 0 or i >= self.n or \
               j < 0 or j >= self.m:

               return
            
            val = grid[i][j]

            if val == ""0"" or val ==""2"":
                return 

            grid[i][j] = ""2""
            dfs_remove_island(i + 1, j)
            dfs_remove_island(i - 1, j)
            dfs_remove_island(i, j + 1)
            dfs_remove_island(i, j - 1)

        count = 0
        for i in range(self.n):
            for j in range(self.m):
                if grid[i][j] == ""1"":
                    count += 1
                    dfs_remove_island(i, j)
        
        return count
        "
,Max Area of Island,Medium,Graphs,"Max Area of Island
Solved 
You are given a matrix grid where grid[i] is either a 0 (representing water) or 1 (representing land).

An island is defined as a group of 1's connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.

The area of an island is defined as the number of cells within the island.

Return the maximum area of an island in grid. If no island exists, return 0.

Example 1:



Input: grid = [
  [0,1,1,0,1],
  [1,0,1,0,1],
  [0,1,1,0,1],
  [0,1,0,0,1]
]

Output: 6
Explanation: 1's cannot be connected diagonally, so the maximum area of the island is 6.

Constraints:

1 <= grid.length, grid[i].length <= 50","class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        self.n = len(grid)
        self.m = len(grid[0])

        def dfs_count_island(i,j):
            if i < 0 or i >= self.n or \
               j < 0 or j >= self.m:
               return 0

            val = grid[i][j]
            if val == 0 or val == 2:
                return 0
            
            grid[i][j] = 2
            u = dfs_count_island(i - 1, j)
            d = dfs_count_island(i + 1, j)
            l = dfs_count_island(i, j - 1)
            r = dfs_count_island(i, j + 1)

            return u + d + l + r + 1

        max_count = 0 
        for i in range(self.n):
            for j in range(self.m):
                if grid[i][j] == 1:
                    new_count = dfs_count_island(i,j)
                    max_count = max(max_count, new_count)
        
        return max_count
        "
,Clone Graph,Medium,Graphs,"Clone Graph
Solved 
Given a node in a connected undirected graph, return a deep copy of the graph.

Each node in the graph contains an integer value and a list of its neighbors.

class Node {
    public int val;
    public List<Node> neighbors;
}
The graph is shown in the test cases as an adjacency list. An adjacency list is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

For simplicity, nodes values are numbered from 1 to n, where n is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node's value (1-indexed).

The input node will always be the first node in the graph and have 1 as the value.

Example 1:



Input: adjList = [[2],[1,3],[2]]

Output: [[2],[1,3],[2]]
Explanation: There are 3 nodes in the graph.
Node 1: val = 1 and neighbors = [2].
Node 2: val = 2 and neighbors = [1, 3].
Node 3: val = 3 and neighbors = [2].

Example 2:



Input: adjList = [[]]

Output: [[]]
Explanation: The graph has one node with no neighbors.

Example 3:

Input: adjList = []

Output: []
Explanation: The graph is empty.

Constraints:

0 <= The number of nodes in the graph <= 100.
1 <= Node.val <= 100
There are no duplicate edges and no self-loops in the graph.","""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""

class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if node is None:
            return None
        self.dic = {}

        def dfs_create(node):
            if node is None:
                return None
            
            if node not in self.dic.keys():
                clone_node = Node(node.val)
                self.dic[node] = clone_node
            
            for neighbor in node.neighbors:
                if neighbor in self.dic.keys():
                    self.dic[node].neighbors.append(self.dic[neighbor])
                else:
                    self.dic[node].neighbors.append(dfs_create(neighbor))
            
            return self.dic[node]

        dfs_create(node)
        return self.dic[node]"
,Islands and Treasure,Medium,Graphs,"Islands and Treasure
Solved 
You are given a 
m
×
n
m×n 2D grid initialized with these three possible values:

-1 - A water cell that can not be traversed.
0 - A treasure chest.
INF - A land cell that can be traversed. We use the integer 2^31 - 1 = 2147483647 to represent INF.
Fill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest then the value should remain INF.

Assume the grid can only be traversed up, down, left, or right.

Modify the grid in-place.

Example 1:

Input: [
  [2147483647,-1,0,2147483647],
  [2147483647,2147483647,2147483647,-1],
  [2147483647,-1,2147483647,-1],
  [0,-1,2147483647,2147483647]
]

Output: [
  [3,-1,0,1],
  [2,2,1,-1],
  [1,-1,2,-1],
  [0,-1,3,4]
]
Example 2:

Input: [
  [0,-1],
  [2147483647,2147483647]
]

Output: [
  [0,-1],
  [1,2]
]
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is one of {-1, 0, 2147483647}","class Solution:
    def islandsAndTreasure(self, grid: List[List[int]]) -> None:
        self.n = len(grid)
        self.m = len(grid[0])

        def dfs(i, j, depth, visited):
            if i < 0 or i >= self.n or \
               j < 0 or j >= self.m:
               return
            if grid[i][j] == -1:
                return
            if f'{i},{j}' in visited.keys() and depth >= grid[i][j]:
                return

            visited[f'{i},{j}'] = True
            grid[i][j] = min(grid[i][j], depth)
            dfs(i + 1, j, depth + 1, visited)
            dfs(i - 1, j, depth + 1, visited)
            dfs(i, j + 1, depth + 1, visited)
            dfs(i, j - 1, depth + 1, visited)
            visited[f'{i},{j}'] = False


        

        for i in range(self.n):
            for j in range(self.m):
                if grid[i][j] == 0:
                    dfs(i, j, 0, {})
        
        "
,Rotting Fruit,Medium,Graphs,"Rotting Fruit
Solved 
You are given a 2-D matrix grid. Each cell can have one of three possible values:

0 representing an empty cell
1 representing a fresh fruit
2 representing a rotten fruit
Every minute, if a fresh fruit is horizontally or vertically adjacent to a rotten fruit, then the fresh fruit also becomes rotten.

Return the minimum number of minutes that must elapse until there are zero fresh fruits remaining. If this state is impossible within the grid, return -1.

Example 1:



Input: grid = [[1,1,0],[0,1,1],[0,1,2]]

Output: 4
Example 2:

Input: grid = [[1,0,1],[0,2,0],[1,0,1]]

Output: -1
Constraints:

1 <= grid.length, grid[i].length <= 10","from collections import deque

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        self.n = len(grid)
        self.m = len(grid[0]) if self.n > 0 else 0
        
        # Count fresh oranges, gather all rotten oranges in a queue (multi-source BFS)
        queue = deque()  # will store tuples (row, col, time)
        fresh_count = 0
        
        for i in range(self.n):
            for j in range(self.m):
                if grid[i][j] == 1:
                    fresh_count += 1
                elif grid[i][j] == 2:
                    # This is a rotten orange, start BFS from here
                    queue.append((i, j, 0))  # time=0 for these initial rotten
        
        # If no fresh oranges from the start, answer is 0
        if fresh_count == 0:
            return 0
        
        # Directions for up, down, left, right
        directions = [(-1,0), (1,0), (0,-1), (0,1)]
        
        final_time = 0  # track maximum minutes
        # BFS: process queue
        while queue:
            row, col, time = queue.popleft()
            
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                # check if valid cell and is fresh (==1)
                if 0 <= nr < self.n and 0 <= nc < self.m and grid[nr][nc] == 1:
                    # rot this fresh orange
                    grid[nr][nc] = 2
                    fresh_count -= 1
                    new_time = time + 1
                    final_time = max(final_time, new_time)
                    # push the newly rotten orange into the queue
                    queue.append((nr, nc, new_time))
        
        # if any fresh oranges remain, return -1
        if fresh_count > 0:
            return -1
        else:
            return final_time"
,Pacific Atlantic Water Flow,Medium,Graphs,"Pacific Atlantic Water Flow
Solved 
You are given a rectangular island heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The islands borders the Pacific Ocean from the top and left sides, and borders the Atlantic Ocean from the bottom and right sides.

Water can flow in four directions (up, down, left, or right) from a cell to a neighboring cell with height equal or lower. Water can also flow into the ocean from cells adjacent to the ocean.

Find all cells where water can flow from that cell to both the Pacific and Atlantic oceans. Return it as a 2D list where each element is a list [r, c] representing the row and column of the cell. You may return the answer in any order.

Example 1:



Input: heights = [
  [4,2,7,3,4],
  [7,4,6,4,7],
  [6,3,5,3,6]
]

Output: [[0,2],[0,4],[1,0],[1,1],[1,2],[1,3],[1,4],[2,0]]
Example 2:

Input: heights = [[1],[1]]

Output: [[0,0],[0,1]]
Constraints:

1 <= heights.length, heights[r].length <= 100
0 <= heights[r][c] <= 1000","class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        self.n = len(heights)
        self.m = len(heights[0])
        
        
        def dfs(i, j, prev_val, oceans_visited):
            if i < 0 or i >= self.n or \
               j < 0 or j >= self.m:
               return False
            
            if prev_val < heights[i][j]:
                return False
            
            if i == 0 or j == 0:
                oceans_visited[""a""] = True
            
            if i == self.n - 1 or j == self.m - 1:
                oceans_visited[""p""] = True
            
            if oceans_visited[""a""] and oceans_visited[""p""]:
                return True
            
            p_val = heights[i][j]
            heights[i][j] = 100000
            u = dfs(i - 1, j, p_val, oceans_visited)
            d = dfs(i + 1, j, p_val, oceans_visited)
            l = dfs(i, j - 1, p_val, oceans_visited)
            r = dfs(i, j + 1, p_val, oceans_visited)
            heights[i][j] = p_val


            return u or d or l or r
        
        ans = []
        for i in range(self.n):
            for j in range(self.m):
                oceans_visited = {
                    ""a"": False,
                    ""p"": False
                }
                
                if dfs(i, j, 1000000, oceans_visited):
                    ans.append([i,j])
        
        return ans"
,Surrounded Regions,Medium,Graphs,"Surrounded Regions
Solved 
You are given a 2-D matrix board containing 'X' and 'O' characters.

If a continous, four-directionally connected group of 'O's is surrounded by 'X's, it is considered to be surrounded.

Change all surrounded regions of 'O's to 'X's and do so in-place by modifying the input board.

Example 1:



Input: board = [
  [""X"",""X"",""X"",""X""],
  [""X"",""O"",""O"",""X""],
  [""X"",""O"",""O"",""X""],
  [""X"",""X"",""X"",""O""]
]

Output: [
  [""X"",""X"",""X"",""X""],
  [""X"",""X"",""X"",""X""],
  [""X"",""X"",""X"",""X""],
  [""X"",""X"",""X"",""O""]
]
Explanation: Note that regions that are on the border are not considered surrounded regions.

Constraints:

1 <= board.length, board[i].length <= 200
board[i][j] is 'X' or 'O'.","class Solution:
    def solve(self, board: List[List[str]]) -> None:
        self.n = len(board)
        self.m = len(board[0])

        def dfs(i,j):
            if i < 0 or i >= self.n or \
               j < 0 or j >= self.m:
               return True
            
            b_val = board[i][j]

            if b_val == ""X"":
                return False

            if b_val == ""Y"":
                return True

            board[i][j] = ""Y""
            u = dfs(i - 1,j)
            d = dfs(i + 1,j)
            l = dfs(i,j - 1)
            r = dfs(i,j + 1)


            return u and d and l and r

            
   
        

        for i in range(self.n):
            for j in range(self.m):
                if board[i][j] == ""O"" and (i == 0 or i == self.n-1 or j == self.m -1 or j == 0):
                    dfs(i,j)

        # Y means visited but not surrounded by X
        # need to convert back to O
        for i in range(self.n):
            for j in range(self.m):
                if board[i][j] == ""O"":
                    board[i][j] = ""X""
        # Y means visited but not surrounded by X
        # need to convert back to O
        for i in range(self.n):
            for j in range(self.m):
                if board[i][j] == ""Y"":
                    board[i][j] = ""O"""
,Open the Lock,Medium,Graphs,"Open the Lock
Solved
Medium
Topics
premium lock icon
Companies
Hint
You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

 

Example 1:

Input: deadends = [""0201"",""0101"",""0102"",""1212"",""2002""], target = ""0202""
Output: 6
Explanation: 
A sequence of valid moves would be ""0000"" -> ""1000"" -> ""1100"" -> ""1200"" -> ""1201"" -> ""1202"" -> ""0202"".
Note that a sequence like ""0000"" -> ""0001"" -> ""0002"" -> ""0102"" -> ""0202"" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end ""0102"".
Example 2:

Input: deadends = [""8888""], target = ""0009""
Output: 1
Explanation: We can turn the last wheel in reverse to move from ""0000"" -> ""0009"".
Example 3:

Input: deadends = [""8887"",""8889"",""8878"",""8898"",""8788"",""8988"",""7888"",""9888""], target = ""8888""
Output: -1
Explanation: We cannot reach the target without getting stuck.
 

Constraints:

1 <= deadends.length <= 500
deadends[i].length == 4
target.length == 4
target will not be in the list deadends.
target and deadends[i] consist of digits only.","# class Solution:
#     def openLock(self, deadends: List[str], target: str) -> int:

#         def generate_possible_moves(code, seen):
#             ans = []
#             for i in range(len(code)):
#                 if code[i] == ""0"":
#                     option_1 = code[:i] + ""1"" + code[i+1:]
#                     option_2 = code[:i] + ""9"" + code[i+1:]
#                     if option_1 not in deadends and seen[option_1] == False:
#                         ans.append(option_1)
#                     if option_2 not in deadends and seen[option_2] == False:
#                         ans.append(option_2)
#                     continue
#                 if code[i] == ""9"":
#                     option_1 = code[:i] + ""0"" + code[i+1:]
#                     option_2 = code[:i] + ""8"" + code[i+1:]
#                     if option_1 not in deadends and seen[option_1] == False:
#                         ans.append(option_1)
#                     if option_2 not in deadends and seen[option_2] == False:
#                         ans.append(option_2)
#                     continue
#                 num = int(code[i])

#                 option_1 = code[:i] + str(num+1) + code[i+1:]
#                 option_2 = code[:i] + str(num-1) + code[i+1:]
#                 if option_1 not in deadends and seen[option_1] == False:
#                     ans.append(option_1)
#                 if option_2 not in deadends and seen[option_2] == False:
#                     ans.append(option_2)

#             return ans
        
        
#         def bfs(code, target, seen):
#             q = [code]
#             depth = 0
#             while q:
#                 len_q = len(q)
#                 for i in range(len_q):
#                     curr_code = q.pop(0)
#                     if seen[curr_code] == False:
#                         seen[curr_code] = True
#                         q += generate_possible_moves(curr_code, seen)

#                         if curr_code == target:
#                             return depth
                
#                 depth += 1
            
#             return -1

#         seen = defaultdict(lambda: False)
#         return bfs(""0000"", target, seen) if ""0000"" not in deadends else -1


class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:

        def children(lock):
            res = []
            for i in range(4):
                digit = str((int(lock[i]) + 1) % 10)
                res.append(lock[:i] + digit + lock[i+1:])
                digit = str((int(lock[i]) - 1 + 10) % 10)
                res.append(lock[:i] + digit + lock[i+1:])
            return res
        
        
        def bfs(code, target, seen):
            q = [code]
            depth = 0
            while q:
                len_q = len(q)
                for i in range(len_q):
                    curr_code = q.pop(0)
                    if seen[curr_code] == False:
                        seen[curr_code] = True
                        q += children(curr_code)

                        if curr_code == target:
                            return depth
                depth += 1
            
            return -1

        seen = defaultdict(lambda: False)
        for deadend in deadends:
            seen[deadend] = True
        return bfs(""0000"", target, seen) if ""0000"" not in deadends else -1"
,Course Schedule,Medium,Graphs,"Course Schedule
Solved 
You are given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b first if you want to take course a.

The pair [0, 1], indicates that must take course 1 before taking course 0.

There are a total of numCourses courses you are required to take, labeled from 0 to numCourses - 1.

Return true if it is possible to finish all courses, otherwise return false.

Example 1:

Input: numCourses = 2, prerequisites = [[0,1]]

Output: true
Explanation: First take course 1 (no prerequisites) and then take course 0.

Example 2:

Input: numCourses = 2, prerequisites = [[0,1],[1,0]]

Output: false
Explanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.

Constraints:

1 <= numCourses <= 1000
0 <= prerequisites.length <= 1000
All prerequisite pairs are unique.","class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        graph = defaultdict(list)
        for a, b in prerequisites:
            graph[a].append(b)

        indegree = defaultdict(int)
        for a, b in prerequisites:
            indegree[b] += 1
        
        q = []
        for course in range(numCourses):
            if indegree[course] == 0:
                q.append(course)

        result = []
        while q:
            level_size = len(q)
            curr = q.pop()
            result.append(curr)

            for neighbor in graph[curr]:
                indegree[neighbor] -= 1

                if indegree[neighbor] == 0:
                    q.append(neighbor)

        if len(result) < numCourses:
            return False
        return True
        "
,Course Schedule II,Medium,Graphs,"Course Schedule II
Solved 
You are given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b first if you want to take course a.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
There are a total of numCourses courses you are required to take, labeled from 0 to numCourses - 1.

Return a valid ordering of courses you can take to finish all courses. If there are many valid answers, return any of them. If it's not possible to finish all courses, return an empty array.

Example 1:

Input: numCourses = 3, prerequisites = [[1,0]]

Output: [0,1,2]
Explanation: We must ensure that course 0 is taken before course 1.

Example 2:

Input: numCourses = 3, prerequisites = [[0,1],[1,2],[2,0]]

Output: []
Explanation: It's impossible to finish all courses.

Constraints:

1 <= numCourses <= 1000
0 <= prerequisites.length <= 1000
All prerequisite pairs are unique.","class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)

        for a, b in prerequisites:
            graph[b].append(a)

        indegree = defaultdict(int)
        for a, b in prerequisites:
            indegree[a] += 1


        q = []
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)
        
        result = []
        while q:
            curr = q.pop(0)
            result.append(curr)

            for neighbor in graph[curr]:
                indegree[neighbor] -= 1

                if indegree[neighbor] == 0:
                    q.append(neighbor)
        
        if len(result) < numCourses:
            return []

        return result

        "
,Graph Valid Tree,Medium,Graphs,"Graph Valid Tree
Solved 
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

Example 1:

Input:
n = 5
edges = [[0, 1], [0, 2], [0, 3], [1, 4]]

Output:
true
Example 2:

Input:
n = 5
edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]

Output:
false
Note:

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.
Constraints:

1 <= n <= 100
0 <= edges.length <= n * (n - 1) / 2","class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        # to be a tree there are n nodes and n-1 edges
        if len(edges) != n - 1:
            return False
        
        if n == 1 and len(edges) == 0:
            return True

        graph = defaultdict(list)
        indegree = defaultdict(int)

        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        for a, b in edges:
            indegree[a] += 1
            indegree[b] += 1
        
        q = []
        for i in range(n):
            # to be a undirected graph the lowest indegree is 1 not 0 for directed, 
            # if we see 0 there is a problem if there are more than 1 nodes in the tree
            if indegree[i] == 1:
                q.append(i)
            elif indegree[i] == 0 and n>1:
                return False

        result = []
        while q:
            curr = q.pop(0)
            result.append(curr)
            indegree[curr] -= 1

            for neighbor in graph[curr]:
                indegree[neighbor] -= 1

                if indegree[neighbor] == 1:
                    q.append(neighbor)
        
        if len(result) < n:
            return False
        
        return True
        "
,Course Schedule IV,Medium,Graphs,"Course Schedule IV
Solved
Medium
Topics
premium lock icon
Companies
Hint
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.

For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.
Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.

You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.

Return a boolean array answer, where answer[j] is the answer to the jth query.

 

Example 1:


Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
Example 2:

Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
Output: [false,false]
Explanation: There are no prerequisites, and each course is independent.
Example 3:


Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
Output: [true,true]
 

Constraints:

2 <= numCourses <= 100
0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)
prerequisites[i].length == 2
0 <= ai, bi <= numCourses - 1
ai != bi
All the pairs [ai, bi] are unique.
The prerequisites graph has no cycles.
1 <= queries.length <= 104
0 <= ui, vi <= numCourses - 1
ui != vi","class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        adj = defaultdict(list)
        indegree = defaultdict(int)

        for i in range(numCourses):
            indegree[i] = 0


        for a, b in prerequisites:
            adj[a].append(b)
            indegree[b] += 1
        
        # q = []
        # for i in range(numCourses):
        #     if indegree[i] == 0:
        #         q.append()
        
        res = []
        for question_prereq, target in queries:
            q = []
            q.append(question_prereq)
            query_solved = False
            visited = {}
            while q:
                curr_course = q.pop(0)
                if curr_course not in visited:
                    visited[curr_course] = True
                    for neighbor in adj[curr_course]:
                        if neighbor == target:
                            query_solved = True
                            break
                        q.append(neighbor)
                    if query_solved:
                        break
            res.append(query_solved)
        return res"
,Number of Connected Components in an Undirected Graph,Medium,Graphs,"Number of Connected Components in an Undirected Graph
Solved 
There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph.

The nodes are numbered from 0 to n - 1.

Return the total number of connected components in that graph.

Example 1:

Input:
n=3
edges=[[0,1], [0,2]]

Output:
1
Example 2:

Input:
n=6
edges=[[0,1], [1,2], [2,3], [4,5]]

Output:
2
Constraints:

1 <= n <= 100
0 <= edges.length <= n * (n - 1) / 2","class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        visited = [False] * n

        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        

        def bfs(node):
            q = [node]
            visited[node] = True

            while q:
                curr = q.pop(0)

                for neighbor in graph[curr]:
                    if visited[neighbor] == False:
                        visited[neighbor] = True
                        q.append(neighbor)
        
        result = 0
        for i in range(n):
            # if not visited explore tree and mark all nodes as visited
            # if find another node not visited increment the count
            if visited[i] == False:
                result += 1
                bfs(i)
        
        return result"
,Redundant Connection,Medium,Graphs,"Redundant Connection
Solved 
You are given a connected undirected graph with n nodes labeled from 1 to n. Initially, it contained no cycles and consisted of n-1 edges.

We have now added one additional edge to the graph. The edge has two different vertices chosen from 1 to n, and was not an edge that previously existed in the graph.

The graph is represented as an array edges of length n where edges[i] = [ai, bi] represents an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input edges.

Example 1:



Input: edges = [[1,2],[1,3],[3,4],[2,4]]

Output: [2,4]
Example 2:



Input: edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]

Output: [3,4]
Constraints:

n == edges.length
3 <= n <= 100
1 <= edges[i][0] < edges[i][1] <= edges.length
There are no repeated edges and no self-loops in the input.","class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        graph = defaultdict(list)
        indegree = defaultdict(int)

        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
            indegree[a] += 1
            indegree[b] += 1
        
        q = []

        for i in range(n+1):
            if indegree[i] == 1:
                q.append(i)
        

        while q:
            curr = q.pop()
            indegree[curr] -= 1
            for neighbor in graph[curr]:
                indegree[neighbor] -= 1

                if indegree[neighbor] == 1:
                    q.append(neighbor)

        for a, b in reversed(edges):
            if indegree[a] == 2 and indegree[b] == 2:
                return [a, b]

        return []
        "
,Accounts Merge,Medium,Graphs,"Accounts Merge
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.

 

Example 1:

Input: accounts = [[""John"",""johnsmith@mail.com"",""john_newyork@mail.com""],[""John"",""johnsmith@mail.com"",""john00@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Output: [[""John"",""john00@mail.com"",""john_newyork@mail.com"",""johnsmith@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Explanation:
The first and second John's are the same person as they have the common email ""johnsmith@mail.com"".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
Example 2:

Input: accounts = [[""Gabe"",""Gabe0@m.co"",""Gabe3@m.co"",""Gabe1@m.co""],[""Kevin"",""Kevin3@m.co"",""Kevin5@m.co"",""Kevin0@m.co""],[""Ethan"",""Ethan5@m.co"",""Ethan4@m.co"",""Ethan0@m.co""],[""Hanzo"",""Hanzo3@m.co"",""Hanzo1@m.co"",""Hanzo0@m.co""],[""Fern"",""Fern5@m.co"",""Fern1@m.co"",""Fern0@m.co""]]
Output: [[""Ethan"",""Ethan0@m.co"",""Ethan4@m.co"",""Ethan5@m.co""],[""Gabe"",""Gabe0@m.co"",""Gabe1@m.co"",""Gabe3@m.co""],[""Hanzo"",""Hanzo0@m.co"",""Hanzo1@m.co"",""Hanzo3@m.co""],[""Kevin"",""Kevin0@m.co"",""Kevin3@m.co"",""Kevin5@m.co""],[""Fern"",""Fern0@m.co"",""Fern1@m.co"",""Fern5@m.co""]]
 

Constraints:

1 <= accounts.length <= 1000
2 <= accounts[i].length <= 10
1 <= accounts[i][j].length <= 30
accounts[i][0] consists of English letters.
accounts[i][j] (for j > 0) is a valid email.","# class Solution:
#     def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
#         accounts_map = defaultdict(list)
#         account_to_name = defaultdict(str)

#         for i in range(len(accounts)):
#             account_to_name[i] = accounts[i][0]
#             accounts_map[accounts[i][1]] = []
#             for j in range(2, len(accounts[i])):
#                 accounts_map[accounts[i][1]].append(accounts[i][j])
        
#         print(f""account_to_name: {account_to_name}"")
#         print(f""accounts_map: {accounts_map}"")
                
# class Solution:
#     def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
#         uf = UnionFind()
#         email_to_name = {}
        
#         # Step 1: Initialize the UnionFind structure and map each email to a name.
#         for account in accounts:
#             name = account[0]
#             first_email = account[1]
#             uf.add(first_email)
#             email_to_name[first_email] = name
#             # Union all emails in the current account.
#             for email in account[1:]:
#                 uf.add(email)
#                 email_to_name[email] = name
#                 uf.union(first_email, email)
#                 print(f""uf.parent: {uf.parent}"")
        
#         # Step 2: Group emails by their root parent.
#         components = {}
#         for email in email_to_name:
#             root = uf.find(email)
#             print(f""email: {email}, root: {root}"")
#             if root not in components:
#                 components[root] = []
#             components[root].append(email)
        
#         print(f""\ncomponents: {components}\n"")
        
#         # Step 3: Build the final merged accounts list.
#         merged_accounts = []
#         for root, emails in components.items():
#             merged_accounts.append([email_to_name[root]] + sorted(emails))
        
#         return merged_accounts

# # UnionFind class as defined above.
# class UnionFind:
#     def __init__(self):
#         self.parent = {}
    
#     def find(self, x):
#         if self.parent[x] != x:
#             self.parent[x] = self.find(self.parent[x])
#         return self.parent[x]
    
#     def union(self, x, y):
#         rootX = self.find(x)
#         rootY = self.find(y)
#         if rootX != rootY:
#             self.parent[rootY] = rootX
    
#     def add(self, x):
#         if x not in self.parent:
#             self.parent[x] = x


class UnionFind:
    def __init__(self):
        self.parent = {}
    
    def add(self, x):
        if x not in self.parent:
            self.parent[x] = x
    
    def find(self, x):
        if self.parent[x] != x:
             self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        parentX = self.find(x)
        parentY = self.find(y)

        if parentX != parentY:
            self.parent[parentY] = parentX

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        uf = UnionFind()
        email_to_name = {}

        for account in accounts:
            name = account[0]
            first_email = account[1]
            uf.add(first_email)
            for email in account[1:]:
                uf.add(email)
                email_to_name[email] = name
                uf.union(first_email, email)
        

        comparison = defaultdict(list)
        for email in email_to_name:
            root = uf.find(email)
            comparison[root].append(email)
        

        ans = []
        for key, val in comparison.items():
            ans.append([email_to_name[key]]+sorted(val))
        
        return ans"
,Evaluate Division,Medium,Graphs,"Evaluate Division
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.

You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.

Return the answers to all queries. If a single answer cannot be determined, return -1.0.

Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.

 

Example 1:

Input: equations = [[""a"",""b""],[""b"",""c""]], values = [2.0,3.0], queries = [[""a"",""c""],[""b"",""a""],[""a"",""e""],[""a"",""a""],[""x"",""x""]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0
Example 2:

Input: equations = [[""a"",""b""],[""b"",""c""],[""bc"",""cd""]], values = [1.5,2.5,5.0], queries = [[""a"",""c""],[""c"",""b""],[""bc"",""cd""],[""cd"",""bc""]]
Output: [3.75000,0.40000,5.00000,0.20000]
Example 3:

Input: equations = [[""a"",""b""]], values = [0.5], queries = [[""a"",""b""],[""b"",""a""],[""a"",""c""],[""x"",""y""]]
Output: [0.50000,2.00000,-1.00000,-1.00000]
 

Constraints:

1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj consist of lower case English letters and digits.","class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        adj_list = defaultdict(list)
        for i in range(len(equations)):
            a, b = equations[i]
            weight = values[i]
            adj_list[a].append([b, weight])
            adj_list[b].append([a, 1/weight])
        
        visited = {}
        def rec(src, target):
            if src not in adj_list or target not in adj_list:
                return -1
            if src == target:
                return 1
            
            visited[src] = True

            total = 1
            for neighor in adj_list[src]:
                next_node, weight = neighor
                if next_node not in visited:
                    val = rec(next_node, target)
                    if val != -1:
                        return val * weight 
            
            return -1
        

        ans = []
        for query in queries:
            visited = {}
            a, b = query
            ans.append(rec(a,b))
        return ans
        "
,Minimum Height Trees,Medium,Graphs,"Minimum Height Trees
Solved
Medium
Topics
premium lock icon
Companies
Hint
A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

 

Example 1:


Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
Example 2:


Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
 

Constraints:

1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
All the pairs (ai, bi) are distinct.
The given input is guaranteed to be a tree and there will be no repeated edges.","class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]
        adj_list = defaultdict(list)
        for u, v in edges:
            adj_list[u].append(v)
            adj_list[v].append(u)
        
        q = []
        for key, value in adj_list.items():
            if len(value) == 1:
                q.append(key)

        count = 1
        while q:
            if n <= 2:
                return q
            leaves = len(q)

            for i in range(leaves):
                node = q.pop(0)
                n -= 1

                for neighbor in adj_list[node]:
                    adj_list[neighbor].remove(node)

                    if len(adj_list[neighbor]) == 1:
                        q.append(neighbor)
        return q"
,Path With Minimum Effort,Medium,Advance Graphs,"Path With Minimum Effort
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.

A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.

Return the minimum effort required to travel from the top-left cell to the bottom-right cell.

 

Example 1:



Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
Example 2:



Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
Example 3:


Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.
 

Constraints:

rows == heights.length
columns == heights[i].length
1 <= rows, columns <= 100
1 <= heights[i][j] <= 106","# class Solution:
#     def minimumEffortPath(self, heights: List[List[int]]) -> int:
#         n = len(heights)
#         m = len(heights[0])
#         memo = {}
#         visited = {}
#         def rec(i,j):
#             if i == n-1 and j == m-1:
#                 return heights[i][j]
#             if i < 0 or i >= n or \
#                j < 0 or j >= m:
#                return 100000
#             if (i,j) in memo:
#                 return memo[(i,j)]
#             u =100000
#             d =100000
#             r =100000
#             l =100000
#             if (i-1,j) not in visited or visited[(i-1,j)] == False:
#                 visited[(i-1,j)] = True
#                 u = rec(i-1,j)
#                 visited[(i-1,j)] = False

#             if (i+1,j) not in visited or visited[(i+1,j)] == False:
#                 visited[(i+1,j)] = True
#                 d = rec(i+1,j)
#                 visited[(i+1,j)] = False
            
#             if (i,j-1) not in visited or visited[(i,j-1)] == False:
#                 visited[(i,j-1)] = True
#                 l = rec(i,j-1)
#                 visited[(i,j-1)] = False
            
#             if (i,j+1) not in visited or visited[(i,j+1)] == False:
#                 visited[(i-1,j)] = True
#                 r = rec(i,j+1)
#                 visited[(i-1,j)] = False

#             memo[(i,j)] = heights[i][j] + min(u,d,r,l)

#             return heights[i][j] + min(u,d,r,l)
        
#         return rec(0,0)

import heapq as hq
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        n = len(heights)
        m = len(heights[0])
        visited = {}
        pq = [[0,0,0]]
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        while pq:
            diff, r, c = hq.heappop(pq)

            if (r,c) in visited and visited[(r,c)] == True:
                continue
            visited[(r,c)] = True

            if r == (n-1) and c == (m-1):
                return diff
            
            for dr, dc in directions:
                new_row = r + dr
                new_col = c +dc

                if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m or ((new_row, new_col) in visited and visited[(new_row, new_col)] == True):
                    continue
                
                hq.heappush(pq, [max(diff, abs(heights[r][c] - heights[new_row][new_col])), new_row, new_col])
        return 0
"
,Network Delay Time,Medium,Advance Graphs,"Network Delay Time
Solved 
You are given a network of n directed nodes, labeled from 1 to n. You are also given times, a list of directed edges where times[i] = (ui, vi, ti).

ui is the source node (an integer from 1 to n)
vi is the target node (an integer from 1 to n)
ti is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to 0).
You are also given an integer k, representing the node that we will send a signal from.

Return the minimum time it takes for all of the n nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return -1 instead.

Example 1:



Input: times = [[1,2,1],[2,3,1],[1,4,4],[3,4,1]], n = 4, k = 1

Output: 3
Example 2:

Input: times = [[1,2,1],[2,3,1]], n = 3, k = 2

Output: -1
Constraints:

1 <= k <= n <= 100
1 <= times.length <= 1000","# class Solution:
#     def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:

#         graph = defaultdict(list)
#         for a, b, c in times:
#             graph[a].append((b,c))
        
#         visited = {}
        
#         q = [(k, 0)]

#         t = 0 
#         while q:
#             curr, time = heapq.heappop(q)
#             if curr in visited:
#                 continue
#             t = time
#             visited[curr] = True

#             for neighbor, neighbor_time in graph[curr]:
#                 if neighbor not in visited:
#                     heapq.heappush(q, (neighbor, neighbor_time + time))
            
#         print(visited)
#         return t if len(visited) == n else -1


class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:

        graph = defaultdict(list)
        for a, b, c in times:
            graph[a].append((b, c))

        visited = {}
        
        q = [(0, k)]

        t = 0 
        while q:
            time, curr = heapq.heappop(q)
            if curr in visited:
                continue
            t = time
            visited[curr] = True

            for neighbor, neighbor_time in graph[curr]:
                if neighbor not in visited:
                    heapq.heappush(q, (neighbor_time + time, neighbor))

        print(visited)
        return t if len(visited) == n else -1"
,Min Cost to Connect Points,Medium,Advance Graphs,"Min Cost to Connect Points
Solved 
You are given a 2-D integer array points, where points[i] = [xi, yi]. Each points[i] represents a distinct point on a 2-D plane.

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between the two points, i.e. |xi - xj| + |yi - yj|.

Return the minimum cost to connect all points together, such that there exists exactly one path between each pair of points.

Example 1:



Input: points = [[0,0],[2,2],[3,3],[2,4],[4,2]]

Output: 10
Constraints:

1 <= points.length <= 1000
-1000 <= xi, yi <= 1000","class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        graph = defaultdict(list)

        for i in range(len(points)):
            x1, y1 = points[i]
            for j in range(i+1, len(points)):
                x2, y2 = points[j]
                man_dist = abs(x2-x1) + abs(y2-y1)
                graph[i].append([man_dist, j])
                graph[j].append([man_dist, i])
                

        q = [[0,0]] #cost point
        result = 0
        visited = {}

        while q:
            cost, curr = heapq.heappop(q)
            if curr in visited:
                continue
            
            result += cost

            visited[curr] = True

            for n_cost, neighbor in graph[curr]:
                if neighbor not in visited:
                    heapq.heappush(q, [n_cost, neighbor])
        
        return result
                    "
,Cheapest Flights Within K Stops,Medium,Advance Graphs,"Cheapest Flights Within K Stops
Solved 
There are n airports, labeled from 0 to n - 1, which are connected by some flights. You are given an array flights where flights[i] = [from_i, to_i, price_i] represents a one-way flight from airport from_i to airport to_i with cost price_i. You may assume there are no duplicate flights and no flights from an airport to itself.

You are also given three integers src, dst, and k where:

src is the starting airport
dst is the destination airport
src != dst
k is the maximum number of stops you can make (not including src and dst)
Return the cheapest price from src to dst with at most k stops, or return -1 if it is impossible.

Example 1:



Input: n = 4, flights = [[0,1,200],[1,2,100],[1,3,300],[2,3,100]], src = 0, dst = 3, k = 1

Output: 500
Explanation:
The optimal path with at most 1 stop from airport 0 to 3 is shown in red, with total cost 200 + 300 = 500.
Note that the path [0 -> 1 -> 2 -> 3] costs only 400, and thus is cheaper, but it requires 2 stops, which is more than k.

Example 2:



Input: n = 3, flights = [[1,0,100],[1,2,200],[0,2,100]], src = 1, dst = 2, k = 1

Output: 200
Explanation:
The optimal path with at most 1 stop from airport 1 to 2 is shown in red and has cost 200.

Constraints:

1 <= n <= 100
fromi != toi
1 <= pricei <= 1000
0 <= src, dst, k < n","class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:

        graph = defaultdict(list)
        for start, end, cost in flights:
            graph[start].append([cost, end])
        
        pq = [[0, 0, src]]
        visited = {}
        result = -1

        while pq:
            cost, count, curr = heapq.heappop(pq)

            # If we've reached the destination, return cost
            if curr == dst:
                return cost

            # If we already used up k stops, we can't proceed further
            if count > k:
                continue
            
            
            new_count = count + 1

            for n_cost, neighbor in graph[curr]:
                # if neighbor not in visited:
                heapq.heappush(pq, [n_cost + cost, new_count, neighbor])
        

        return -1

        "
,Climbing Stairs,Easy,1-D Dynamic Programming,"Climbing Stairs
Solved 
You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.

Return the number of distinct ways to climb to the top of the staircase.

Example 1:

Input: n = 2

Output: 2
Explanation:

1 + 1 = 2
2 = 2
Example 2:

Input: n = 3

Output: 3
Explanation:

1 + 1 + 1 = 3
1 + 2 = 3
2 + 1 = 3
Constraints:

1 <= n <= 30","# class Solution:
#     def climbStairs(self, n: int) -> int:
#         if n == 0:
#             return 0
#         if n == 1:
#             return 1
#         count = 0
#         prev_one = 0
#         prev_two = 1
#         for i in range(0,n):
#             count = prev_one + prev_two

#             prev_one = prev_two
#             prev_two = count
        
#         return count

class Solution:
    def climbStairs(self, n: int) -> int:

        def rec(num):
            if num < 0:
                return 0
            if num == 0:
                return 1
            
            op_one = rec(num-1)
            op_two = rec(num-2)

            return op_one + op_two
        
        return rec(n)
"
,Min Cost Climbing Stairs,Easy,1-D Dynamic Programming,"Min Cost Climbing Stairs
Solved 
You are given an array of integers cost where cost[i] is the cost of taking a step from the ith floor of a staircase. After paying the cost, you can step to either the (i + 1)th floor or the (i + 2)th floor.

You may choose to start at the index 0 or the index 1 floor.

Return the minimum cost to reach the top of the staircase, i.e. just past the last index in cost.

Example 1:

Input: cost = [1,2,3]

Output: 2
Explanation: We can start at index = 1 and pay the cost of cost[1] = 2 and take two steps to reach the top. The total cost is 2.

Example 2:

Input: cost = [1,2,1,2,1,1,1]

Output: 4
Explanation: Start at index = 0.

Pay the cost of cost[0] = 1 and take two steps to reach index = 2.
Pay the cost of cost[2] = 1 and take two steps to reach index = 4.
Pay the cost of cost[4] = 1 and take two steps to reach index = 6.
Pay the cost of cost[6] = 1 and take one step to reach the top.
The total cost is 4.
Constraints:

2 <= cost.length <= 100
0 <= cost[i] <= 100","# class Solution:
#     def minCostClimbingStairs(self, cost: List[int]) -> int:
#         def rec(n):
#             if n < 0:
#                 return 0
#             if n == 0:
#                 return cost[n]
            
#             op_one = rec(n - 1)
#             op_two = rec(n - 2)

#             if n == len(cost):
#                 return min(op_one, op_two)

#             return min(op_one, op_two) + cost[n]
        
#         return rec(len(cost))


class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        if len(cost) == 1:
            return cost[0]
        prev = cost[0]
        curr = cost[1]
        count = 0
        for i in range(2,len(cost)):
            count = min(prev, curr) + cost[i]


            prev = curr
            curr = count
        
        return min(prev, curr)"
,N-th Tribonacci Number,Easy,1-D Dynamic Programming,"N-th Tribonacci Number
Solved
Easy
Topics
premium lock icon
Companies
Hint
The Tribonacci sequence Tn is defined as follows: 

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

 

Example 1:

Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Example 2:

Input: n = 25
Output: 1389537
 

Constraints:

0 <= n <= 37
The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.","class Solution:
    def tribonacci(self, n: int) -> int:
        memo = {}
        def rec(m):
            if m in memo:
                return memo[m]
            if m == 0:
                return 0
            if m <= 2:
                return 1
            
            memo[m] = rec(m-1) + rec(m-2) + rec(m-3)
            return memo[m]
        
        return rec(n)


# class Solution:
#     def tribonacci(self, n: int) -> int:
#         memo = {}
        
#         def helper(n):
#             if n in memo:
#                 return memo[n]
#             if n == 0:
#                 return 0
#             elif n == 1 or n == 2:
#                 return 1
#             else:
#                 result = helper(n - 1) + helper(n - 2) + helper(n - 3)
#                 memo[n] = result
#                 return result
        
#         return helper(n)"
,House Robber,Medium,1-D Dynamic Programming,"House Robber
Solved 
You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a straight line, i.e. the ith house is the neighbor of the (i-1)th and (i+1)th house.

You are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.

Return the maximum amount of money you can rob without alerting the police.

Example 1:

Input: nums = [1,1,3,3]

Output: 4
Explanation: nums[0] + nums[2] = 1 + 3 = 4.

Example 2:

Input: nums = [2,9,8,3,6]

Output: 16
Explanation: nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16.

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100","# class Solution:
#     def rob(self, nums: List[int]) -> int:
#         self.memo = {}
        
#         def rec(n):
#             if n < 0:
#                 return 0
#             if n == 0:
#                 return nums[0]

#             if n in self.memo:
#                 return self.memo[n]
            
#             op_one = rec(n - 1)
#             op_two = rec(n - 2)

#             self.memo[n] = max(op_one, op_two + nums[n])

#             return self.memo[n]
        
#         return rec(len(nums) - 1)



class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 0:
            return 0
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])

        
        prev = nums[0]
        curr = max(nums[0],nums[1])

        print(f""prev: {prev}, curr: {curr}"")
        for i in range(2, n):
            count = max(prev + nums[i], curr)
            prev = curr
            curr = count
            print(f""prev: {prev}, curr: {curr}"")

        return count"
,House Robber II,Medium,1-D Dynamic Programming,"House Robber II
Solved 
You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.

You are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.

Return the maximum amount of money you can rob without alerting the police.

Example 1:

Input: nums = [3,4,3]

Output: 4
Explanation: You cannot rob nums[0] + nums[2] = 6 because nums[0] and nums[2] are adjacent houses. The maximum you can rob is nums[1] = 4.

Example 2:

Input: nums = [2,9,8,3,6]

Output: 15
Explanation: You cannot rob nums[0] + nums[2] + nums[4] = 16 because nums[0] and nums[4] are adjacent houses. The maximum you can rob is nums[1] + nums[4] = 15.

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100","# class Solution:
#     def rob(self, nums: List[int]) -> int:
#         t = len(nums)
#         if t == 1:
#             return nums[0]
#         if t == 2:
#             return max(nums[0], nums[1])

#         self.memo = {}


#         def rec(start, end):
#             if end < start:
#                 return 0
#             if end == start:
#                 return nums[start]
#             if end in self.memo:
#                 return self.memo[end]
            
#             op_one = rec(start, end - 1)
#             op_two = rec(start, end - 2)

#             self.memo[end] = max(op_two + nums[end], op_one)

#             return self.memo[end]
        
#         one = rec(0, t-2)
#         self.memo = {}
#         two = rec(1, t-1)
        
#         return max(one, two)


class Solution:
    def rob(self, nums: List[int]) -> int:
        t = len(nums)
        if t == 1:
            return nums[0]
        if t == 2:
            return max(nums[0], nums[1])
            
        prev_one = nums[0]
        curr_one = max(nums[0], nums[1])
        count_one = 0

        for i in range(2,t-1):
            count_one = max(prev_one + nums[i], curr_one)
            prev_one = curr_one
            curr_one = count_one
        
        ans_one = max(curr_one, prev_one)

        prev_two = nums[1]
        curr_two = max(nums[2], nums[1])
        count_two = 0
        for i in range(3, t):
            count_two = max(prev_two + nums[i], curr_two)
            prev_two = curr_two
            curr_two = count_two
        
        ans_two = max(curr_two, prev_two)

        return max(ans_one, ans_two)"
,Longest Palindromic Substring,Medium,1-D Dynamic Programming,"Longest Palindromic Substring
Solved 
Given a string s, return the longest substring of s that is a palindrome.

A palindrome is a string that reads the same forward and backward.

If there are multiple palindromic substrings that have the same length, return any one of them.

Example 1:

Input: s = ""ababd""

Output: ""bab""
Explanation: Both ""aba"" and ""bab"" are valid answers.

Example 2:

Input: s = ""abbc""

Output: ""bb""
Constraints:

1 <= s.length <= 1000
s contains only digits and English letters.","class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) == 1:
            return s
        
        def is_pal(left, right):
            max_string = ''
            while left >= 0 and right <= len(s)-1:
                if s[left] != s[right]:
                    return max_string
                
                max_string = s[left:right+1]

                left -= 1
                right += 1
            
            return max_string
        
        
        m_string = is_pal(0, 0)
        for i in range(1, len(s)):
            candidate_one = is_pal(i, i)
            candidate_two = is_pal(i-1, i)

            if len(candidate_one) > len(candidate_two) and len(candidate_one) > len(m_string):
                m_string = candidate_one
            elif len(candidate_two) > len(candidate_one) and len(candidate_two) > len(m_string):
                m_string = candidate_two

        return m_string"
,Palindromic Substrings,Medium,1-D Dynamic Programming,"Palindromic Substrings
Solved 
Given a string s, return the number of substrings within s that are palindromes.

A palindrome is a string that reads the same forward and backward.

Example 1:

Input: s = ""abc""

Output: 3
Explanation: ""a"", ""b"", ""c"".

Example 2:

Input: s = ""aaa""

Output: 6
Explanation: ""a"", ""a"", ""a"", ""aa"", ""aa"", ""aaa"". Note that different substrings are counted as different palindromes even if the string contents are the same.

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.","# class Solution:
#     def countSubstrings(self, s: str) -> int:
#         def is_pal(word):
#             left = 0
#             right = len(word)-1

#             while left < right:
#                 if s[left] != s[right]:
#                     return False
                
#                 left += 1
#                 right -= 1
            
#             return True
        
#         self.paths = []
#         def combination(start, word):
#             if len(word) != 0 and is_pal(word):
#                 self.paths.append(word)
            
#             if start > len(s)-1:
#                 return
            
#             for i in range(start, len(s)):
#                 word = word + s[i]
#                 combination(i+1, word)
#                 word = word[:-1]
            
#             return

        
#         combination(0,'')
#         print(self.paths)
#         return len(self.paths)

class Solution:
    def countSubstrings(self, s: str) -> int:
        def is_pal(word: str) -> bool:
            left, right = 0, len(word) - 1
            while left < right:
                if word[left] != word[right]:
                    return False
                left += 1
                right -= 1
            return True
        
        self.paths = []  # to store palindromic contiguous substrings
        
        # This recursive helper builds a contiguous substring starting at index `start`
        # by always appending the next character.
        def contiguous(start: int, word: str) -> None:
            if start >= len(s):
                return
            new_word = word + s[start]
            if is_pal(new_word):
                self.paths.append(new_word)
            # Only move to the next character (ensuring contiguity)
            contiguous(start + 1, new_word)
        
        # Try every possible starting index for a contiguous substring.
        for i in range(len(s)):
            contiguous(i, """")
        
        return len(self.paths)"
,Decode Ways,Medium,1-D Dynamic Programming,"Decode Ways
Solved 
A string consisting of uppercase english characters can be encoded to a number using the following mapping:

'A' -> ""1""
'B' -> ""2""
...
'Z' -> ""26""
To decode a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, ""1012"" can be mapped into:

""JAB"" with the grouping (10 1 2)
""JL"" with the grouping (10 12)
The grouping (1 01 2) is invalid because 01 cannot be mapped into a letter since it contains a leading zero.

Given a string s containing only digits, return the number of ways to decode it. You can assume that the answer fits in a 32-bit integer.

Example 1:

Input: s = ""12""

Output: 2

Explanation: ""12"" could be decoded as ""AB"" (1 2) or ""L"" (12).
Example 2:

Input: s = ""01""

Output: 0
Explanation: ""01"" cannot be decoded because ""01"" cannot be mapped into a letter.

Constraints:

1 <= s.length <= 100
s consists of digits","class Solution:
    def numDecodings(self, s: str) -> int:

        def rec(st):
            if st == '':
                return 1 

            
            first_letter = st[0]
            no_first_letter_count = 0
            if first_letter != '0' and int(first_letter) <= 26:
                no_first_letter = st[1:]
                no_first_letter_count = rec(no_first_letter)

            first_two_letters = st[:2]
            no_first_two_letters_count = 0
            if first_letter != '0' and len(first_two_letters) == 2 and int(first_two_letters) <= 26:
                no_first_two_letters = st[2:]
                no_first_two_letters_count = rec(no_first_two_letters)
            

            return no_first_letter_count + no_first_two_letters_count
        
        return rec(s)
        
# class Solution:
#     def numDecodings(self, s: str) -> int:

#         def rec(st):
#             # Base case: an empty string means we've found a valid decoding.
#             if st == '':
#                 return 1    

#             first_letter = st[0]
#             no_first_letter_count = 0
#             # If the first character is valid (non-'0'), decode it as a single digit.
#             if first_letter != '0':
#                 no_first_letter = st[1:]
#                 no_first_letter_count = rec(no_first_letter)
            
#             no_first_two_letters_count = 0
#             # If there are at least two characters and the two-digit number is valid,
#             # decode them as a pair.
#             if len(st) >= 2 and st[0] != '0' and int(st[:2]) <= 26:
#                 no_first_two_letters = st[2:]
#                 no_first_two_letters_count = rec(no_first_two_letters)
            
#             return no_first_letter_count + no_first_two_letters_count
        
#         return rec(s)"
,Coin Change,Medium,1-D Dynamic Programming,"Coin Change
Solved 
You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.

Return the fewest number of coins that you need to make up the exact target amount. If it is impossible to make up the amount, return -1.

You may assume that you have an unlimited number of each coin.

Example 1:

Input: coins = [1,5,10], amount = 12

Output: 3
Explanation: 12 = 10 + 1 + 1. Note that we do not have to use every kind coin available.

Example 2:

Input: coins = [2], amount = 3

Output: -1
Explanation: The amount of 3 cannot be made up with coins of 2.

Example 3:

Input: coins = [1], amount = 0

Output: 0
Explanation: Choosing 0 coins is a valid way to make up 0.

Constraints:

1 <= coins.length <= 10
1 <= coins[i] <= 2^31 - 1
0 <= amount <= 10000","class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        self.min_amount = 1000000
        coins.reverse()
        memo = {}

        def rec(total, count):
            if total < 0:
                return 
            if count >= self.min_amount:
                return
            if total in memo and count >= memo[total]:
                return memo[total]
            if total == 0:
                self.min_amount = min(self.min_amount, count)
                return 

            
            for coin in coins:
                rec(total - coin, count + 1)

            if total not in memo:
                memo[total] = count
            else:
                memo[total] = min(memo[total], count)

            return
        
        rec(amount, 0)
        return -1 if self.min_amount == 1000000 else self.min_amount
            "
,Maximum Product Subarray,Medium,1-D Dynamic Programming,"Maximum Product Subarray
Solved 
Given an integer array nums, find a subarray that has the largest product within the array and return it.

A subarray is a contiguous non-empty sequence of elements within an array.

You can assume the output will fit into a 32-bit integer.

Example 1:

Input: nums = [1,2,-3,4]

Output: 4
Example 2:

Input: nums = [-2,-1]

Output: 2
Constraints:

1 <= nums.length <= 1000
-10 <= nums[i] <= 10","class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        cur_min = 1
        cur_max = 1

        total_max = -10000000
        for num in nums:
            if num == 0:
                cur_min = 1
                cur_max = 1
            
            new_val_one = cur_max * num
            new_val_two = cur_min * num
            cur_min = min(new_val_one, new_val_two, num)
            cur_max = max(new_val_one, new_val_two, num)

            total_max = max(total_max, cur_max)

        return total_max"
,Word Break,Medium,1-D Dynamic Programming,"Word Break
Solved 
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words.

You are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.

Example 1:

Input: s = ""neetcode"", wordDict = [""neet"",""code""]

Output: true
Explanation: Return true because ""neetcode"" can be split into ""neet"" and ""code"".

Example 2:

Input: s = ""applepenapple"", wordDict = [""apple"",""pen"",""ape""]

Output: true
Explanation: Return true because ""applepenapple"" can be split into ""apple"", ""pen"" and ""apple"". Notice that we can reuse words and also not use all the words.

Example 3:

Input: s = ""catsincars"", wordDict = [""cats"",""cat"",""sin"",""in"",""car""]

Output: false
Constraints:

1 <= s.length <= 200
1 <= wordDict.length <= 100
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.","class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        letter_to_word = defaultdict(list)
        memo = {}

        def rec(st):
            if st == '':
                return True
            
            if st in memo:
                return memo[st]
            
            overall = False
            for word in wordDict:
                if st[:len(word)] != word:
                    continue
                
                overall = overall or rec(st[len(word):])
            memo[st] = overall
            
            return overall
        
        return rec(s)

        "
,Longest Increasing Subsequence,Medium,1-D Dynamic Programming,"Longest Increasing Subsequence
Solved 
Given an integer array nums, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.

For example, ""cat"" is a subsequence of ""crabt"".
Example 1:

Input: nums = [9,1,4,2,3,3,7]

Output: 4
Explanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.

Example 2:

Input: nums = [0,3,1,3,2,3]

Output: 4
Constraints:

1 <= nums.length <= 1000
-1000 <= nums[i] <= 1000","# class Solution:
#     def lengthOfLIS(self, nums: List[int]) -> int:
        
#         self.res = []

#         def rec(idx, path):
#             if idx == len(nums):
#                 self.res.append(path[:])
#                 return

#             if path == []:
#                 path.append(nums[idx])
#                 rec(idx + 1, path)
#                 path.pop()
#                 rec(idx + 1, path)
#             else:
#                 last_taken = path[-1]

#                 if nums[idx] > last_taken:
#                     path.append(nums[idx])
#                     rec(idx + 1, path)
#                     path.pop()
#                 rec(idx + 1, path)
            
#             return
#         rec(0, [])
#         max_length = 0

#         for ans in self.res:
#             max_length = max(max_length, len(ans))

#         return max_length


class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        
        self.res = []

        def rec(idx, last_taken_idx):
            if idx == len(nums):
                return 0
            taken = 0
            not_taken = 0
            if last_taken_idx == -1:
                taken = rec(idx + 1, idx) + 1
                not_taken = rec(idx + 1, last_taken_idx)
            else:
                if nums[idx] > nums[last_taken_idx]:
                    taken = rec(idx + 1, idx) + 1
                not_taken = rec(idx + 1, last_taken_idx)
            
            return max(taken, not_taken)
        

        return rec(0, -1)"
,Partition Equal Subset Sum,Medium,1-D Dynamic Programming,"Partition Equal Subset Sum
Solved 
You are given an array of positive integers nums.

Return true if you can partition the array into two subsets, subset1 and subset2 where sum(subset1) == sum(subset2). Otherwise, return false.

Example 1:

Input: nums = [1,2,3,4]

Output: true
Explanation: The array can be partitioned as [1, 4] and [2, 3].

Example 2:

Input: nums = [1,2,3,4,5]

Output: false
Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 50","class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        memo = {}

        total_sum = sum(nums)
        half_sum = total_sum//2

        if total_sum % 2 == 1:
            return False
        
        def rec(val, start):
            if val < 0:
                return False
            if val == 0:
                return True
            if val in memo and memo[val]:
                return memo[val]
            
            overall = False

            for i in range(start,len(nums)):
                overall = overall or rec(val-nums[i], i+1)
            memo[val] = overall
            return overall
        
        return rec(half_sum, 0)


        "
,Combination Sum IV,Medium,1-D Dynamic Programming,"Combination Sum IV
Solved
Medium
Topics
premium lock icon
Companies
Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.

The test cases are generated so that the answer can fit in a 32-bit integer.

 

Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:

Input: nums = [9], target = 3
Output: 0
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 1000
All the elements of nums are unique.
1 <= target <= 1000
 

Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?","class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        memo = {}
        def rec(start, target):
            if target == 0:
                return 1
            if target < 0:
                return 0
            if (start, target) in memo:
                return memo[(start, target)] 
            
            count = 0
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i-1]:
                    continue
                count += rec(i, target-nums[i])
            
            memo[(start, target)] = count
            
            return memo[(start, target)]
        c = rec(0, target)
        return c
        "
,Integer Break,Medium,1-D Dynamic Programming,"Integer Break
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

 

Example 1:

Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Example 2:

Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
 

Constraints:

2 <= n <= 58","# class Solution:
#     def integerBreak(self, n: int) -> int:
#         if n == 2:
#             return 1
#         if n == 3:
#             return 2

#         max_prod = n-1
#         def rec(start, m, prod):
#             nonlocal max_prod
#             if m == 0:
#                 max_prod = max(max_prod, prod)
#                 return
#             if m < 0:
#                 return
#             for i in range(start, m+1):
#                 rec(i, m - i, prod * i)
            
#             return
        
#         rec(1, n, 1)
#         return max_prod


# class Solution:
#     def integerBreak(self, n: int) -> int:
#         # Memo to avoid recomputing
#         memo = {}

#         def dfs(x: int) -> int:
#             # If we've already computed the best for x
#             if x in memo:
#                 return memo[x]

#             # For x <= 2, the best product is x-1 
#             # (this enforces at least one break)
#             if x <= 2:
#                 return x - 1

#             best = 0
#             # Try breaking x into i + (x - i)
#             for i in range(1, x):
#                 # Either take i * (x - i) or i * dfs(x - i)
#                 # The max ensures we consider further breaks vs. no further breaks
#                 best = max(best, i * (x - i), i * dfs(x - i))

#             memo[x] = best
#             return best

#         return dfs(n)






class Solution:
    def integerBreak(self, n: int) -> int:

        max_prod = n-1
        def rec(start, m, prod, count):
            nonlocal max_prod
            if m == 0 and count >= 2:
                max_prod = max(max_prod, prod)
                return
            if m < 0:
                return
            for i in range(start, m+1):
                rec(i, m - i, prod * i, count+1)
            
            return
        
        rec(1, n, 1, 0)
        return max_prod"
,Perfect Squares,Medium,1-D Dynamic Programming,"Perfect Squares
Solved
Medium
Topics
premium lock icon
Companies
Given an integer n, return the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

 

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
 

Constraints:

1 <= n <= 104","class Solution:
    def numSquares(self, n: int) -> int:
        sqrt_n = math.floor(n ** (1/2))
        min_count = 100000

        def rec(end, target, count):
            nonlocal min_count
            if target == 0:
                min_count = min(min_count, count)
                return 
            if target < 0:
                return 
            if count >= min_count:
                return
            
            for i in range(end, 0, -1):
                rec(i, target - i**2, count + 1)

            return 
        rec(sqrt_n, n, 0)
        return min_count"
,Unique Paths,Medium,2-D Dynamic Programming,"Unique Paths
Solved 
There is an m x n grid where you are allowed to move either down or to the right at any point in time.

Given the two integers m and n, return the number of possible unique paths that can be taken from the top-left corner of the grid (grid[0][0]) to the bottom-right corner (grid[m - 1][n - 1]).

You may assume the output will fit in a 32-bit integer.

Example 1:



Input: m = 3, n = 6

Output: 21
Example 2:

Input: m = 3, n = 3

Output: 6
Constraints:

1 <= m, n <= 100","class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        def rec(i, j):
            if i < 0 or i >= m or \
               j < 0 or j >= n:
               return 0
            if i == m-1 and j == n-1:
                return 1
            
            right = rec(i, j + 1)
            down = rec(i + 1, j)

            return right + down
        
        return rec(0, 0)

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        grid = [[1 for _ in range(n)] for _ in range(m)]

        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] = grid[i-1][j] + grid[i][j-1]
        
        return grid[m-1][n-1]

# 1. 1.  1. 1.   1    1    1     1 
# 1  2   3  4.   5    6    7.    8
# 1  3.  6. 10   15   21   28    36
# 1. 4  10. 20   35   56   84    120
# 1. 5. 15  35   70   126  210.  330
# 1  6. 21  56.  126  252. 462.  792
# 1. 7. 28. 84.  210. 462. 924   1716
# 1. 8. 36. 120. 330  792  1716  3432"
, Unique Paths II,Medium,2-D Dynamic Programming,"Unique Paths II
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The testcases are generated so that the answer will be less than or equal to 2 * 109.

 

Example 1:


Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
Example 2:


Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
 

Constraints:

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] is 0 or 1.","class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        memo = {}
        n = len(obstacleGrid)
        m = len(obstacleGrid[0])
        if obstacleGrid[n-1][m-1] == 1:
            return 0

        def rec(i, j):
            if i == n-1 and j == m-1:
                return 1
            
            if i < 0 or i >= n or \
               j < 0 or j >= m or \
               obstacleGrid[i][j]:
               return 0
            if (i,j) in memo:
                return memo[(i,j)]
            
            r = rec(i + 1, j)
            d = rec(i, j + 1)

            memo[(i,j)] = r + d

            return r+ d
        
        return rec(0, 0)

        "
,Minimum Path Sum,Medium,2-D Dynamic Programming,"Minimum Path Sum
Solved
Medium
Topics
premium lock icon
Companies
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

 

Example 1:


Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 200","class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        memo = {}

        def rec(i,j):
            if i == n-1 and j == m-1:
                return grid[i][j]
            if i < 0 or i >= n or \
               j < 0 or j >= m:
               return 1000000
            
            if (i,j) in memo:
                return memo[(i,j)]
            
            r = rec(i+1,j)
            d = rec(i,j+1)

            memo[(i,j)] = min(r,d) + grid[i][j]
            return memo[(i,j)]
        

        return rec(0,0)"
,Longest Common Subsequence,Medium,2-D Dynamic Programming,"Longest Common Subsequence
Solved 
Given two strings text1 and text2, return the length of the longest common subsequence between the two strings if one exists, otherwise return 0.

A subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.

For example, ""cat"" is a subsequence of ""crabt"".
A common subsequence of two strings is a subsequence that exists in both strings.

Example 1:

Input: text1 = ""cat"", text2 = ""crabt"" 

Output: 3 
Explanation: The longest common subsequence is ""cat"" which has a length of 3.

Example 2:

Input: text1 = ""abcd"", text2 = ""abcd""

Output: 4
Example 3:

Input: text1 = ""abcd"", text2 = ""efgh""

Output: 0
Constraints:

1 <= text1.length, text2.length <= 1000
text1 and text2 consist of only lowercase English characters.","class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m = len(text1)
        n = len(text2)

        grid = [[0 for _ in range(n+1)] for _ in range(m+1)]


        for i in range(1, m+1):
            for j in range(1, n+1):
                if text1[i-1] == text2[j-1] :
                    grid[i][j] = grid[i-1][j-1] + 1
                else:
                    grid[i][j] = max(grid[i-1][j], grid[i][j-1])

        return grid[m][n]

# class Solution:
#     def longestCommonSubsequence(self, text1: str, text2: str) -> int:
#         def rec(i, j):
#             if i >= len(text1) or j >= len(text2):
#                 return 0

#             if text1[i] == text2[j]:
#                 return 1 + rec(i + 1, j + 1)
            
#             return max(rec(i + 1, j), rec(i, j + 1))
        
#         # Start the recursion from the beginning of both strings.
#         return rec(0, 0)

   

#     c.    r.  a.  b.  t
# c.  1.    1.  1.  1.  1

# a.  1.    1.  2.  2.  2

# t.  1.    1   2.  2.  3"
,Last Stone Weight II,Medium,2-D Dynamic Programming,"Last Stone Weight II
Solved
Medium
Topics
premium lock icon
Companies
Hint
You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, return 0.

 

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.
Example 2:

Input: stones = [31,26,33,21,40]
Output: 5
 

Constraints:

1 <= stones.length <= 30
1 <= stones[i] <= 100","class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        stone_sum = sum(stones)
        target = (stone_sum + 1)//2
        memo = {}


        #the goal is to get 0, so if the sum is 38 we are looking for stones adding to 19
        # if the sum is 39 we will have at best value of 1 left since 19 will cancel with 19 stones leaving 1
        # so we really have a target of 19 that if we reach -1 we found out answer
    
        def rec(i, val):
            print(f""val <= 0: {val <= 0}, i == len(stones): {i == len(stones)}"")
            if val <= 0 or i == len(stones):
                pile1 = stone_sum - target - abs(val)
                pile2 = target + abs(val)
                print(f""stone_sum: {stone_sum}, target: {target}, val: {val}, pile1: {pile1}, pile2: {pile2}"")

                return pile2 - pile1
            if (i, val) in memo:
                return memo[(i,val)]
            
            memo[(i,val)] = min(rec(i + 1, val), rec(i + 1, val - stones[i]))
            return memo[(i,val)]
        
        return rec(0, target)"
,Best Time to Buy and Sell Stock with Cooldown,Medium,2-D Dynamic Programming,"Best Time to Buy and Sell Stock with Cooldown
Solved 
You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may buy and sell one NeetCoin multiple times with the following restrictions:

After you sell your NeetCoin, you cannot buy another one on the next day (i.e., there is a cooldown period of one day).
You may only own at most one NeetCoin at a time.
You may complete as many transactions as you like.

Return the maximum profit you can achieve.

Example 1:

Input: prices = [1,3,4,0,4]

Output: 6
Explanation: Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 + 4 = 6.

Example 2:

Input: prices = [1]

Output: 0
Constraints:

1 <= prices.length <= 5000
0 <= prices[i] <= 1000","class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        self.n = len(prices)
        
        def rec(idx, have_coin):
            if idx >= self.n:
                return 0
            
            # options
            # buy or skip
            if have_coin == False:
                #buy
                option_1 = rec(idx + 1, True) - prices[idx]
                #skip
                option_2 = rec(idx + 1, False)
             
            else:
                # sell
                option_1 = rec(idx + 2, False) + prices[idx]
                #skip
                option_2 = rec(idx + 1, True)
            
            return max(option_1, option_2)
        
        return rec(0, False)
                
           
            "
,Coin Change II,Medium,2-D Dynamic Programming,"Coin Change II
Solved 
You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.

Return the number of distinct combinations that total up to amount. If it's impossible to make up the amount, return 0.

You may assume that you have an unlimited number of each coin and that each value in coins is unique.

Example 1:

Input: amount = 4, coins = [1,2,3]

Output: 4
Explanation:

1+1+1+1 = 4
1+1+2 = 4
2+2 = 4
1+3 = 4
Example 2:

Input: amount = 7, coins = [2,4]

Output: 0
Constraints:

1 <= coins.length <= 100
1 <= coins[i] <= 5000
0 <= amount <= 5000","class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        memo = {}

        def rec(total, start):
            if total < 0:
                return 0
            if total == 0:
                return 1
            if f""{total},{start}"" in memo:
                return memo[f""{total},{start}""]
            
            count = 0
            for i in range(start, len(coins)):
                count += rec(total - coins[i], i)
            
            memo[f""{total},{start}""] = count
            
            return count
        
        return rec(amount, 0)
        "
,Target Sum,Medium,2-D Dynamic Programming,"Target Sum
Solved 
You are given an array of integers nums and an integer target.

For each number in the array, you can choose to either add or subtract it to a total sum.

For example, if nums = [1, 2], one possible sum would be ""+1-2=-1"".
If nums=[1,1], there are two different ways to sum the input numbers to get a sum of 0: ""+1-1"" and ""-1+1"".

Return the number of different ways that you can build the expression such that the total sum equals target.

Example 1:

Input: nums = [2,2,2], target = 2

Output: 3
Explanation: There are 3 different ways to sum the input numbers to get a sum of 2.
+2 +2 -2 = 2
+2 -2 +2 = 2
-2 +2 +2 = 2

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 1000
-1000 <= target <= 1000","class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        def rec(idx, val):
            if idx == len(nums):
                if val == 0:
                    return 1
                return 0

            add_op = rec(idx + 1, val + nums[idx])
            sub_op = rec(idx + 1, val - nums[idx])

            return add_op + sub_op
        
        return rec(0, target)"
,Interleaving String,Medium,2-D Dynamic Programming,"Interleaving String
Solved 
You are given three strings s1, s2, and s3. Return true if s3 is formed by interleaving s1 and s2 together or false otherwise.

Interleaving two strings s and t is done by dividing s and t into n and m substrings respectively, where the following conditions are met

|n - m| <= 1, i.e. the difference between the number of substrings of s and t is at most 1.
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
Interleaving s and t is s1 + t1 + s2 + t2 + ... or t1 + s1 + t2 + s2 + ...
You may assume that s1, s2 and s3 consist of lowercase English letters.

Example 1:



Input: s1 = ""aaaa"", s2 = ""bbbb"", s3 = ""aabbbbaa""

Output: true
Explanation: We can split s1 into [""aa"", ""aa""], s2 can remain as ""bbbb"" and s3 is formed by interleaving [""aa"", ""aa""] and ""bbbb"".

Example 2:

Input: s1 = """", s2 = """", s3 = """"

Output: true
Example 3:

Input: s1 = ""abc"", s2 = ""xyz"", s3 = ""abxzcy""

Output: false
Explanation: We can't split s3 into [""ab"", ""xz"", ""cy""] as the order of characters is not maintained.

Constraints:

0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200","class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n = len(s1)
        m = len(s2)
        o = len(s3)

        if n + m != o:
            return False
        
        def rec(i, j, path):
            if path != s3[:len(path)]:
                return False
            if i >= n and j >= m:
                if path == s3:
                    return True
                return False

            res = False
            if i < n :
                s3_idx = i + j

                path = path + s1[i]
                res = res or rec(i + 1, j, path)
                path = path[:-1]

            if j < m:
                path = path + s2[j]
                res = res or rec(i, j + 1, path)
                path = path[:-1]

            
            return res

        return rec(0, 0, '')
            
            "
,Stone Game,Medium,2-D Dynamic Programming,"Stone Game
Solved
Medium
Topics
premium lock icon
Companies
Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.

Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.

 

Example 1:

Input: piles = [5,3,4,5]
Output: true
Explanation: 
Alice starts first, and can only take the first 5 or the last 5.
Say she takes the first 5, so that the row becomes [3, 4, 5].
If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.
If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alice, so we return true.
Example 2:

Input: piles = [3,7,2,3]
Output: true
 

Constraints:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles[i]) is odd.","# class Solution:
#     def stoneGame(self, piles: List[int]) -> bool:
#         if len(piles) == 1:
#             return True
        
#         sum_piles = sum(piles)
#         win_num = sum_piles // 2

#         visited = {}

#         def rec(updated_piles, alices_score, alices_turn):
#             if len(updated_piles) == 0:
#                 return alices_score
            
#             if f""({updated_piles}, {alices_score})"" in visited.keys():
#                 return visited[f""({updated_piles}, {alices_score})""]

#             left_pile = updated_piles[0]
#             after_left_removed = updated_piles[1:]

#             right_pile = updated_piles[-1]
#             after_right_removed = updated_piles[:-1]

#             if alices_turn:
#                 l_alices_score = alices_score + left_pile
#                 lr = rec(after_left_removed, l_alices_score, not alices_turn)

#                 r_alices_score = alices_score + right_pile
#                 rr = rec(after_right_removed, r_alices_score, not alices_turn)

#                 score = max(lr, rr)
            
#             else:
#                 lr = rec(after_left_removed, alices_score, not alices_turn)

#                 rr = rec(after_right_removed, alices_score, not alices_turn)

#                 score = min(lr, rr)

#                 visited[f""({updated_piles}, {alices_score})""] = score
            
#             return score
        

#         return rec(piles, 0, True) > win_num


# class Solution:
#     def stoneGame(self, piles: List[int]) -> bool:
#         n = len(piles)
#         memo = {}
        
#         def rec(l, r, alice_turn):
#             if l > r:
#                 return 0
            
#             if (l, r, alice_turn) in memo:
#                 return memo[(l, r, alice_turn)]
            
#             if alice_turn:
#                 # Alice adds to her score
#                 score_left = piles[l] + rec(l+1, r, False)
#                 score_right = piles[r] + rec(l, r-1, False)
#                 best_score = max(score_left, score_right)
#             else:
#                 # Bob's turn; if you want to maximize Alice's final score, 
#                 # you can interpret Bob's turn as ""Bob subtracts from Alice's net""
#                 # Or interpret Bob as playing optimally and we want Alice's net.
#                 # Typically we'd do:
#                 score_left = rec(l+1, r, True) - piles[l]
#                 score_right = rec(l, r-1, True) - piles[r]
#                 best_score = min(score_left, score_right)
            
#             memo[(l, r, alice_turn)] = best_score
#             return best_score
        
#         total = sum(piles)
#         # bestScore is the difference between Alice's and Bob's score if we interpret 
#         # Bob subtracting from the net. If bestScore > 0, Alice has more stones.
#         bestScore = rec(0, n-1, True)
#         return bestScore > 0


class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)
        memo = {}
        def rec(left, right, difference, alices_turn):
            if left > right:
                return difference
            
            if (left, right, alices_turn) in memo:
                return memo[(left, right, alices_turn)]
            
            option1 = piles[left]
            option2 = piles[right]

            if not alices_turn:
                option1 *= -1
                option2 *= -1
            
            play1 = rec(left + 1, right, difference + option1, not alices_turn)
            play2 = rec(left, right - 1, difference + option2, not alices_turn)

            memo[(left, right, alices_turn)] = max(play1, play2)

            return memo[(left, right, alices_turn)]
        
        return rec(0, n-1, 0, True) > 0"
,Stone Game II,Medium,2-D Dynamic Programming,"Stone Game II
Solved
Medium
Topics
premium lock icon
Companies
Hint
Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.

Alice and Bob take turns, with Alice starting first.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M. Then, we set M = max(M, X). Initially, M = 1.

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

 

Example 1:

Input: piles = [2,7,9,4,4]

Output: 10

Explanation:

If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 stones in total.
If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 stones in total.
So we return 10 since it's larger.

Example 2:

Input: piles = [1,2,3,4,5,100]

Output: 104

 

Constraints:

1 <= piles.length <= 100
1 <= piles[i] <= 104","# class Solution:
#     def stoneGameII(self, piles: List[int]) -> int:
#         n = len(piles)
#         memo = {}

#         def rec(left, right, alices_turn, M):
#             nonlocal n
#             if left > right:
#                 return 0
#             if (left, right, alices_turn, M) in memo:
#                 return memo[(left, right, alices_turn, M)]
            
#             remaining = right - left + 1
#             pile_count_left = 0
#             if alices_turn:
#                 best = 0
#                 for i in range(min(2 * M, remaining) + 1):
#                     i = i + 1
#                     current = sum(piles[left:left + i]) + rec(left + i, right, False, max(M, i))
#                     best = max(best, current)
                
#                 memo[(left, right, alices_turn, M)] = best
#                 return memo[(left, right, alices_turn, M)]

#             else:
#                 worst = 100000000
#                 for i in range(min(2 * M, remaining) + 1):
#                     i = i + 1

#                     current = rec(left + i, right, True, max(M, i))

#                     worst = min(worst, current)
                
#                 memo[(left, right, alices_turn, M)] = worst
#                 return memo[(left, right, alices_turn, M)]

        
#         return rec(0, n-1, True, 1)

class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        memo = {}

        def rec(left, right, alices_turn, M):
            nonlocal n
            if left > right:
                return 0
            if (left, right, alices_turn, M) in memo:
                return memo[(left, right, alices_turn, M)]
            
            remaining = right - left + 1
            pile_count_left = 0
            if alices_turn:
                best = 0
                for i in range(min(2 * M, remaining)):
                    i = i + 1
                    current = sum(piles[left:left + i]) + rec(left + i, right, False, max(M, i))
                    best = max(best, current)
                
                memo[(left, right, alices_turn, M)] = best
                return memo[(left, right, alices_turn, M)]

            else:
                worst = 100000000
                for i in range(min(2 * M, remaining)):
                    i = i + 1

                    current = rec(left + i, right, True, max(M, i))

                    worst = min(worst, current)
                
                memo[(left, right, alices_turn, M)] = worst
                return memo[(left, right, alices_turn, M)]

        
        return rec(0, n-1, True, 1)


# class Solution:
#     def stoneGameII(self, piles: List[int]) -> int:
#         n = len(piles)
#         memo = {}

#         def rec(left, right, alices_turn, M):
#             nonlocal n
#             if left > right:
#                 return 0
#             if (left, right, alices_turn, M) in memo:
#                 return memo[(left, right, alices_turn, M)]
            
#             remaining = right - left + 1
#             if alices_turn:
#                 best = 0
#                 # x goes from 1 to the allowed maximum number of piles.
#                 for x in range(1, min(2 * M, remaining) + 1):
#                     current = sum(piles[left:left + x]) + rec(left + x, right, False, max(M, x))
#                     best = max(best, current)
#                 memo[(left, right, alices_turn, M)] = best
#                 return best
#             else:
#                 worst = float('inf')
#                 for x in range(1, min(2 * M, remaining) + 1):
#                     current = rec(left + x, right, True, max(M, x))
#                     worst = min(worst, current)
#                 memo[(left, right, alices_turn, M)] = worst
#                 return worst

#         return rec(0, n - 1, True, 1)"
,Longest Increasing Path in Matrix,Hard,2-D Dynamic Programming,"Longest Increasing Path in Matrix
Solved 
You are given a 2-D grid of integers matrix, where each integer is greater than or equal to 0.

Return the length of the longest strictly increasing path within matrix.

From each cell within the path, you can move either horizontally or vertically. You may not move diagonally.

Example 1:



Input: matrix = [[5,5,3],[2,3,6],[1,1,1]]

Output: 4
Explanation: The longest increasing path is [1, 2, 3, 6] or [1, 2, 3, 5].

Example 2:



Input: matrix = [[1,2,3],[2,1,4],[7,6,5]]

Output: 7
Explanation: The longest increasing path is [1, 2, 3, 4, 5, 6, 7].

Constraints:

1 <= matrix.length, matrix[i].length <= 100","class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        n = len(matrix)
        m = len(matrix[0])

        def gen_options(i,j,prev_val):
            all_options = [[1,0],[-1, 0], [0,1], [0,-1]]

            res = []
            for row, col in all_options:
                new_row = i + row
                new_col = j + col
                if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:
                    continue
                
                if matrix[new_row][new_col] <= prev_val:
                    continue
                
                res.append([row,col])
            
            return res

        
        def rec(i, j, prev_val, count):
            if i < 0 or i >= n or \
               j < 0 or j >= m:

               return 0

            path_options = gen_options(i,j, matrix[i][j])
            if len(path_options) == 0:
                return count
            
            max_depth = 0
            for row, col in path_options:
                max_depth = max(max_depth, rec(i + row, j + col, matrix[i][j], count + 1))
            
            return max_depth
        

        max_val = -10000
        for i in range(n):
            for j in range(m):
                max_val = max(max_val, rec(i, j, -100000, 1))
        
        return max_val"
,Edit Distance,Medium,2-D Dynamic Programming,"Edit Distance
Solved 
You are given two strings word1 and word2, each consisting of lowercase English letters.

You are allowed to perform three operations on word1 an unlimited number of times:

Insert a character at any position
Delete a character at any position
Replace a character at any position
Return the minimum number of operations to make word1 equal word2.

Example 1:

Input: word1 = ""monkeys"", word2 = ""money""

Output: 2
Explanation:
monkeys -> monkey (remove s)
monkey -> monkey (remove k)

Example 2:

Input: word1 = ""neatcdee"", word2 = ""neetcode""

Output: 3
Explanation:
neatcdee -> neetcdee (replace a with e)
neetcdee -> neetcde (remove last e)
neetcde -> neetcode (insert o)

Constraints:

0 <= word1.length, word2.length <= 100
word1 and word2 consist of lowercase English letters.","class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        if word1 == word2:
            return 0
        
        n = len(word1)
        m = len(word2)
        memo = {}
        def rec(i, j):
            if i == n:
                return m - j
            
            if j == m:
                return n - i
            
            if (i,j) in memo:
                return memo[(i,j)]
            
            res = 10000000
            if word1[i] == word2[j]:
                res = rec(i + 1, j + 1)
            else:
                res = min(res, rec(i + 1, j), rec(i, j + 1), rec(i + 1, j + 1)) + 1
            
            memo[(i,j)] = res
            
            return res 
        
        return rec(0,0)"
,Lemonade Change,Easy,Greedy,"Lemonade Change
Solved
Easy
Topics
premium lock icon
Companies
At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.

Note that you do not have any change in hand at first.

Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.

 

Example 1:

Input: bills = [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.
Example 2:

Input: bills = [5,5,10,10,20]
Output: false
Explanation: 
From the first two customers in order, we collect two $5 bills.
For the next two customers in order, we collect a $10 bill and give back a $5 bill.
For the last customer, we can not give the change of $15 back because we only have two $10 bills.
Since not every customer received the correct change, the answer is false.
 

Constraints:

1 <= bills.length <= 105
bills[i] is either 5, 10, or 20.","class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        if bills[0] != 5:
            return False
        
        fives = 0
        tens = 0
        for bill in bills:
            if bill == 5:
                 fives += 1
            elif bill == 10:
                if fives > 0:
                    fives -= 1
                    tens += 1
                else:
                    return False
            else:
                if fives > 0 and tens > 0:
                    fives -= 1
                    tens -= 1
                elif fives >= 3:
                    fives -= 3
                else: 
                    return False
                    
        return True
        "
,Maximum Subarray,Medium,Greedy,"Maximum Subarray
Solved 
Given an array of integers nums, find the subarray with the largest sum and return the sum.

A subarray is a contiguous non-empty sequence of elements within an array.

Example 1:

Input: nums = [2,-3,4,-2,2,1,-1,4]

Output: 8
Explanation: The subarray [4,-2,2,1,-1,4] has the largest sum 8.

Example 2:

Input: nums = [-1]

Output: -1
Constraints:

1 <= nums.length <= 1000
-1000 <= nums[i] <= 1000","class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        right = 1

        max_seen = nums[0]
        ans = max(nums[0], 0)
        while right < len(nums):
            ans = max(ans+nums[right], nums[right])
            max_seen = max(max_seen, ans)
            right += 1
        
        return max_seen

[-2,1,-3,4,-1,2,1,-5,4]
[ 0,1,-2,4, 3,5,6, 1, 5]"
,Maximum Sum Circular Subarray,Medium,Greedy,"Maximum Sum Circular Subarray
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.

A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].

A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.

 

Example 1:

Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3.
Example 2:

Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.
Example 3:

Input: nums = [-3,-2,-3]
Output: -2
Explanation: Subarray [-2] has maximum sum -2.
 

Constraints:

n == nums.length
1 <= n <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104","class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        #find min window
        min_window = nums[0]
        global_min = nums[0]
        for num in nums[1:]:
            min_window = min(num, min_window + num)
            global_min = min(global_min, min_window)

        #find max window
        max_window = nums[0]
        global_max = nums[0]
        for num in nums[1:]:
            max_window = max(num, max_window + num)
            global_max = max(global_max, max_window)

        #total window
        total_window = sum(nums)

        if global_max < 0:
            return global_max
        #total window - min window can be a possible max window option, but we need to compare

        return max(global_max, (total_window - global_min))"
,Longest Turbulent Subarray,Medium,Greedy,"Longest Turbulent Subarray
Solved
Medium
Topics
premium lock icon
Companies
Given an integer array arr, return the length of a maximum size turbulent subarray of arr.

A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:

For i <= k < j:
arr[k] > arr[k + 1] when k is odd, and
arr[k] < arr[k + 1] when k is even.
Or, for i <= k < j:
arr[k] > arr[k + 1] when k is even, and
arr[k] < arr[k + 1] when k is odd.
 

Example 1:

Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
Example 2:

Input: arr = [4,8,12,16]
Output: 2
Example 3:

Input: arr = [100]
Output: 1
 

Constraints:

1 <= arr.length <= 4 * 104
0 <= arr[i] <= 109","# class Solution:
#     def maxTurbulenceSize(self, arr: List[int]) -> int:
#         if len(arr) == 1:
#             return 1

#         for i in range(len(arr)-1):
#             arr[i] = arr[i+1] - arr[i]
        
#         max_count = 1 if sum(arr[:-1]) != 0 else 0
#         count = 1
#         for i in range(len(arr)-2):
            
#             if arr[i] == 0 or arr[i+1] == 0:
#                 count = 1
#                 continue

#             if arr[i]/abs(arr[i]) != arr[i+1]/abs(arr[i+1]):
#                 count += 1
#             else:
#                 count = 1
            
#             max_count = max(max_count, count)
#         return 1 if max_count == 0 else max_count + 1


class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        l, r, res, prev = 0, 1, 1, """"

        while r < len(arr):
            if arr[r - 1] > arr[r] and prev != "">"":
                res = max(res, r - l + 1)
                r += 1
                prev = "">""
            elif arr[r - 1] < arr[r] and prev != ""<"":
                res = max(res, r - l + 1)
                r += 1
                prev = ""<""
            else:
                r = r + 1 if arr[r] == arr[r - 1] else r
                l = r - 1
                prev = """"

        return res"
,Jump Game,Medium,Greedy,"Jump Game
Solved 
You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.

Return true if you can reach the last index starting from index 0, or false otherwise.

Example 1:

Input: nums = [1,2,0,1,0]

Output: true
Explanation: First jump from index 0 to 1, then from index 1 to 3, and lastly from index 3 to 4.

Example 2:

Input: nums = [1,2,1,0,1]

Output: false
Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 1000","class Solution:
    def canJump(self, nums: List[int]) -> bool:
        
        left = 0
        steps_left = nums[0]
        while steps_left != 0 and left < len(nums)-1:
            steps_left -= 1
            left += 1
            steps_left = max(steps_left, nums[left])
        
        return True if left >= len(nums)-1 else False"
,Jump Game II,Medium,Greedy,"Jump Game II
Solved 
You are given an array of integers nums, where nums[i] represents the maximum length of a jump towards the right from index i. For example, if you are at nums[i], you can jump to any index i + j where:

j <= nums[i]
i + j < nums.length
You are initially positioned at nums[0].

Return the minimum number of jumps to reach the last position in the array (index nums.length - 1). You may assume there is always a valid answer.

Example 1:

Input: nums = [2,4,1,1,1,1]

Output: 2
Explanation: Jump from index 0 to index 1, then jump from index 1 to the last index.

Example 2:

Input: nums = [2,1,2,1,0]

Output: 2
Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 100","class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        graph = defaultdict(list)

        for i in range(len(nums)):
            for j in range(1, nums[i]+1):
                graph[i].append(i + j)
        
        print(graph)
        
        queue = [0]
        jumps = 0
        

        while queue:
            jumps += 1
            level_size = len(queue)
            for i in range(level_size):
                curr = queue.pop(0)

                for neighbors in graph[curr]:
                    if neighbors >= len(nums)-1:
                        return jumps
                    queue.append(neighbors)
        
        return 0"
,Jump Game VII,Medium,Greedy,"Jump Game VII
Attempted
Medium
Topics
premium lock icon
Companies
Hint
You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:

i + minJump <= j <= min(i + maxJump, s.length - 1), and
s[j] == '0'.
Return true if you can reach index s.length - 1 in s, or false otherwise.

 

Example 1:

Input: s = ""011010"", minJump = 2, maxJump = 3
Output: true
Explanation:
In the first step, move from index 0 to index 3. 
In the second step, move from index 3 to index 5.
Example 2:

Input: s = ""01101110"", minJump = 2, maxJump = 3
Output: false
 

Constraints:

2 <= s.length <= 105
s[i] is either '0' or '1'.
s[0] == '0'
1 <= minJump <= maxJump < s.length","# class Solution:
#     def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
#         n = len(s)-1
#         memo = {}

#         def rec(idx):
#             if idx == n:
#                 return True
            
#             if idx > n:
#                 return False
#             if idx in memo:
#                 return memo[idx]
            
#             ans = False
#             for i in range(maxJump, minJump-1, -1):
#                 new_idx = (idx + i)
#                 if new_idx > n  or s[new_idx] != '0':
#                     if  new_idx == n and  s[new_idx] != '0':
#                         memo[idx] = False
#                         return False
#                     continue
                
#                 if rec(new_idx):
#                     memo[idx] = True
#                     return True

            
#             memo[idx] = False
            
#             return False
        
#         return False if s[0] != '0' else rec(0)



class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        n = len(s)
        dp = [None] * n
        dp[n - 1] = True

        def dfs(i):
            if dp[i] is not None:
                return dp[i]

            dp[i] = False
            for j in range(i + minJump, min(n, i + maxJump + 1)):
                if s[j] == '0' and dfs(j):
                    dp[i] = True
                    break

            return dp[i]

        if s[-1] == '1':
            return False
        return dfs(0)"
,Gas Station,Medium,Greedy,"Gas Station
Solved 
There are n gas stations along a circular route. You are given two integer arrays gas and cost where:

gas[i] is the amount of gas at the ith station.
cost[i] is the amount of gas needed to travel from the ith station to the (i + 1)th station. (The last station is connected to the first station)
You have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index such that you can travel around the circuit once in the clockwise direction. If it's impossible, then return -1.

It's guaranteed that at most one solution exists.

Example 1:

Input: gas = [1,2,3,4], cost = [2,2,4,1]

Output: 3
Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 1 + 1 = 4
Travel to station 1. Your tank = 4 - 2 + 2 = 4
Travel to station 2. Your tank = 4 - 2 + 3 = 5
Travel to station 3. Your tank = 5 - 4 + 4 = 5

Example 2:

Input: gas = [1,2,3], cost = [2,3,2]

Output: -1
Explanation:
You can't start at station 0 or 1, since there isn't enough gas to travel to the next station.
If you start at station 2, you can move to station 0, and then station 1.
At station 1 your tank = 0 + 3 - 2 + 1 - 2 = 0.
You're stuck at station 1, so you can't travel around the circuit.

Constraints:

1 <= gas.length == cost.length <= 1000
0 <= gas[i], cost[i] <= 1000","class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:

        def is_possible(idx, fuel, used):
            if fuel < 0:
                return False
            if idx in used.keys() and used[idx]:
                return True

            old_fuel = fuel
            fuel = fuel + (gas[idx] - cost[idx])
            used[idx] = True
            old_idx = idx
            if idx ==len(gas) -1:
                idx = 0
            else:
                idx += 1
            print(f""start idx: {old_idx}, moving to idx: {idx}, old fuel: {old_fuel}, with this much fuel left at destination: {fuel}"")

            ans = is_possible(idx, fuel, used)

            fuel = old_fuel
            used[idx] = False
            idx = old_idx

            return ans
            
        
        for i in range(len(gas)):
            print(""\n\nnew round:"")
            if is_possible(i, 0, {}):
                return i
        return -1"
,Hand of Straights,Medium,Greedy,"Hand of Straights
Solved 
You are given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize.

You want to rearrange the cards into groups so that each group is of size groupSize, and card values are consecutively increasing by 1.

Return true if it's possible to rearrange the cards in this way, otherwise, return false.

Example 1:

Input: hand = [1,2,4,2,3,5,3,4], groupSize = 4

Output: true
Explanation: The cards can be rearranged as [1,2,3,4] and [2,3,4,5].

Example 2:

Input: hand = [1,2,3,3,4,5,6,7], groupSize = 4

Output: false
Explanation: The closest we can get is [1,2,3,4] and [3,5,6,7], but the cards in the second group are not consecutive.

Constraints:

1 <= hand.length <= 1000
0 <= hand[i] <= 1000
1 <= groupSize <= hand.length","class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        hand.sort()
        hands = [[hand[0]]]
        for i in range(1, len(hand)):
            added = False
            for fan in hands:
                if added == True:
                    continue
                if len(fan) == groupSize:
                    continue
                if hand[i] == fan[-1] + 1:
                    fan.append(hand[i])
                    added = True
            
            if added == False:
                hands.append([hand[i]])
        
        for fan in hands:
            if len(fan) != groupSize:
                return False
        
        return True
                


        "
,Dota2 Senate,Medium,Greedy,"Dota2 Senate
Solved
Medium
Topics
premium lock icon
Companies
In the world of Dota2, there are two parties: the Radiant and the Dire.

The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:

Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.
Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.
Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.

The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.

Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be ""Radiant"" or ""Dire"".

 

Example 1:

Input: senate = ""RD""
Output: ""Radiant""
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.
Example 2:

Input: senate = ""RDD""
Output: ""Dire""
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And the third senator comes from Dire and he can ban the first senator's right in round 1. 
And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.
 

Constraints:

n == senate.length
1 <= n <= 104
senate[i] is either 'R' or 'D'.","# class Solution:
#     def predictPartyVictory(self, senate: str) -> str:
#         party_count = defaultdict(int)

#         for party in senate:
#             party_count[party] += 1
        
#         D_to_remove = 0
#         R_to_remove = 0
#         for party in senate:
#             if party == 'D' and D_to_remove > 0:
#                 D_to_remove -= 1
#                 continue
#             if party == 'R' and R_to_remove > 0:
#                 R_to_remove -= 1
#                 continue

#             if party == 'R':
#                 party_count['D'] -= 1
#                 D_to_remove += 1
#             else:
#                 party_count['R'] -= 1
#                 R_to_remove += 1
            
#             if party_count['R'] == 0:
#                 return 'Dire'
#             if party_count['D'] == 0:
#                 return 'Radiant'
#         if party_count['R'] == party_count['D']:
#             return 'Radiant' if senate[-1] == 'R' else 'Dire'
#         return 'Radiant' if max(party_count, key=party_count.get) == 'R' else 'Dire'


class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        D, R = deque(), deque()
        n = len(senate)

        for i, c in enumerate(senate):
            if c == 'R':
                R.append(i)
            else:
                D.append(i)

        while D and R:
            dTurn = D.popleft()
            rTurn = R.popleft()

            if rTurn < dTurn:
                R.append(rTurn + n)
            else:
                D.append(dTurn + n)

        return ""Radiant"" if R else ""Dire"""
,Merge Triplets to Form Target,Medium,Greedy,"Merge Triplets to Form Target
Solved 
You are given a 2D array of integers triplets, where triplets[i] = [ai, bi, ci] represents the ith triplet. You are also given an array of integers target = [x, y, z] which is the triplet we want to obtain.

To obtain target, you may apply the following operation on triplets zero or more times:

Choose two different triplets triplets[i] and triplets[j] and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
* E.g. if triplets[i] = [1, 3, 1] and triplets[j] = [2, 1, 2], triplets[j] will be updated to [max(1, 2), max(3, 1), max(1, 2)] = [2, 3, 2].

Return true if it is possible to obtain target as an element of triplets, or false otherwise.

Example 1:

Input: triplets = [[1,2,3],[7,1,1]], target = [7,2,3]

Output: true
Explanation:
Choose the first and second triplets, update the second triplet to be [max(1, 7), max(2, 1), max(3, 1)] = [7, 2, 3].

Example 2:

Input: triplets = [[2,5,6],[1,4,4],[5,7,5]], target = [5,4,6]

Output: false
Constraints:

1 <= triplets.length <= 1000
1 <= ai, bi, ci, x, y, z <= 100","class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:


        store = [-1000000,-1000000,-1000000]

        for a, b, c in triplets:
            if a > target[0] or b > target[1] or c > target[2]:
                continue
            
            store = [max(store[0], a),\
                     max(store[1], b),
                     max(store[2], c)
                    ]
            print(store)
        return store == target

            

        "
,Partition Labels,Medium,Greedy,"Partition Labels
Solved 
You are given a string s consisting of lowercase english letters.

We want to split the string into as many substrings as possible, while ensuring that each letter appears in at most one substring.

Return a list of integers representing the size of these substrings in the order they appear in the string.

Example 1:

Input: s = ""xyxxyzbzbbisl""

Output: [5, 5, 1, 1, 1]
Explanation: The string can be split into [""xyxxy"", ""zbzbb"", ""i"", ""s"", ""l""].

Example 2:

Input: s = ""abcabc""

Output: [6]
Constraints:

1 <= s.length <= 100","# class Solution:
#     def partitionLabels(self, s: str) -> List[int]:
#         #find the first letter 
#         #find the last position of the first in the string
#         #check all letters in substring
#         #from right find first appearance of one of the letters in the substring
#         #and thats the substring
#         # remove substring found
#         # repeat until no letters are left in s
#         ans = []
#         while s != '':
#             left = 0
#             right = len(s)-1

#             while left < right and s[left] != s[right]:
#                 right -= 1
            
#             dic = {}
#             for i in range(left, right + 1):
#                 dic[s[i]] = True
            
#             left = 0
#             right = len(s)-1
            
#             print(dic)
#             while left < right and s[right] not in dic.keys():
#                 right -= 1
#             ans.append(right-left+1)
#             s = s[right+1:]
        
#         return ans
        
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        last_index = defaultdict(int)

        for i in range(len(s)):
            last_index[s[i]] = max(last_index[s[i]], i)
        
        print(last_index)
        
        count = 1
        curr = 0
        end = 0
        ans = []
        while curr < len(s):
            curr_letter = s[curr]
            end = max(end, last_index[curr_letter])
            if curr == end:
                ans.append(count)
                count = 0
            curr += 1
            count += 1 
        
        return ans
"
,Valid Parenthesis String,Medium,Greedy,"Valid Parenthesis String
Solved 
You are given a string s which contains only three types of characters: '(', ')' and '*'.

Return true if s is valid, otherwise return false.

A string is valid if it follows all of the following rules:

Every left parenthesis '(' must have a corresponding right parenthesis ')'.
Every right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
A '*' could be treated as a right parenthesis ')' character or a left parenthesis '(' character, or as an empty string """".
Example 1:

Input: s = ""((**)""

Output: true
Explanation: One of the '*' could be a ')' and the other could be an empty string.

Example 2:

Input: s = ""(((*)""

Output: false
Explanation: The string is not valid because there is an extra '(' at the beginning, regardless of the extra '*'.

Constraints:

1 <= s.length <= 100","class Solution:
    def checkValidString(self, s: str) -> bool:
        memo = {}
        def rec(idx, open_count):
            if open_count < 0:
                return False
            if idx == len(s) and open_count == 0:
                return True
            if idx == len(s):
                return False
            if (idx, open_count) in memo:
                return memo[(idx, open_count)]
            
            val = s[idx]
            ans = False
            if val == ""("":
                ans = rec(idx + 1, open_count + 1)
            elif val == "")"":
                ans = rec(idx + 1, open_count - 1)
            else:
                # * is open parenthesis 
                op_1 = rec(idx + 1, open_count + 1)
                # * is clos parenthesis 
                op_2 = rec(idx + 1, open_count - 1)
                # * is empty string
                op_3 = rec(idx + 1, open_count)

                ans = op_1 or op_2 or op_3
            memo[(idx, open_count)] = ans
            
            return ans
        

        return rec(0,0)"
,Insert Interval,Medium,Intervals,"Insert Interval
Solved 
You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] represents the start and the end time of the ith interval. intervals is initially sorted in ascending order by start_i.

You are given another interval newInterval = [start, end].

Insert newInterval into intervals such that intervals is still sorted in ascending order by start_i and also intervals still does not have any overlapping intervals. You may merge the overlapping intervals if needed.

Return intervals after adding newInterval.

Note: Intervals are non-overlapping if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.

Example 1:

Input: intervals = [[1,3],[4,6]], newInterval = [2,5]

Output: [[1,6]]
Example 2:

Input: intervals = [[1,2],[3,5],[9,10]], newInterval = [6,7]

Output: [[1,2],[3,5],[6,7],[9,10]]
Constraints:

0 <= intervals.length <= 1000
newInterval.length == intervals[i].length == 2
0 <= start <= end <= 1000","class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        
        # first_start = intervals[0][0]
        # first_end = intervals[0][1]

        # for i in range(1, len(intervals)):
        #     second_start = intervals[i][0]
        #     second_end = intervals[i][1]

        #     if newInterval[0] > first_end and newInterval[1] < second_start:
        #         #insert interval into i postion and return
        #         print(f""here if 1"")
        #         intervals.insert(i, newInterval)
        #         return intervals
        #     elif newInterval[0] <= first_end and newInterval[1] >= second_start:
        #         print(f""here if 2"")
        #         new_list = [min(newInterval[0], first_start), max(newInterval[1], second_end)]
        #         intervals.pop(i)
        #         intervals.insert(i, new_list)
        #         intervals.pop(i-1)
        #     elif newInterval[0] <= first_end and newInterval[1] < second_start:
        #         print(f""here if 3eee"")
        #         intervals[i-1][1] = max(first_end, newInterval[1])

        #     elif newInterval[0] >= first_end and newInterval[1] <= second_end:
        #         print(f""here if 3"")
        #         new_list = [min(newInterval[0], first_end), max(newInterval[1], second_end)]
        #         intervals.pop(i)
        #         intervals.insert(i, new_list)
            
        #     elif newInterval[0] <= first_start and newInterval[1] <= first_end:
        #         print(f""here if 4"")
        #         new_list = [min(newInterval[0], first_start), max(newInterval[1], first_end)]
        #         intervals.pop(i-1)
        #         intervals.insert(i-1, new_list)

        #     start = second_start
        #     end = second_end
        
        # print(intervals)
        # return intervals
        ans = []
        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                ans.append(newInterval)
                return ans + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                ans.append(intervals[i])
            else:
                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
        
        ans.append(newInterval)
        return ans"
,Merge Intervals,Medium,Intervals,"Merge Intervals
Solved 
Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

You may return the answer in any order.

Note: Intervals are non-overlapping if they have no common point. For example, [1, 2] and [3, 4] are non-overlapping, but [1, 2] and [2, 3] are overlapping.

Example 1:

Input: intervals = [[1,3],[1,5],[6,7]]

Output: [[1,5],[6,7]]
Example 2:

Input: intervals = [[1,2],[2,3]]

Output: [[1,3]]
Constraints:

1 <= intervals.length <= 1000
intervals[i].length == 2
0 <= start <= end <= 1000","class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        ans = []
        intervals.sort()
        newInterval = [intervals[0][0],intervals[0][1]]
        for i in range(1, len(intervals)):
            if newInterval[1] < intervals[i][0]:
                ans.append(newInterval)
                newInterval = intervals[i]
            elif newInterval[0] > intervals[i][1]:
                ans.append(intervals[i])
            else:
                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
        
        ans.append(newInterval)
        return ans
        "
,Non-overlapping Intervals,Medium,Intervals,"Non-overlapping Intervals
Solved 
Given an array of intervals intervals where intervals[i] = [start_i, end_i], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Note: Intervals are non-overlapping even if they have a common point. For example, [1, 3] and [2, 4] are overlapping, but [1, 2] and [2, 3] are non-overlapping.

Example 1:

Input: intervals = [[1,2],[2,4],[1,4]]

Output: 1
Explanation: After [1,4] is removed, the rest of the intervals are non-overlapping.

Example 2:

Input: intervals = [[1,2],[2,4]]

Output: 0
Constraints:

1 <= intervals.length <= 1000
intervals[i].length == 2
-50000 <= starti < endi <= 50000","# class Solution:
#     def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
#         intervals.sort()
#         new_interval = intervals[0][:]
#         count = 0

#         for i in range(1, len(intervals)):
#             if new_interval[1] <= intervals[i][0]:
#                 new_interval = intervals[i]
#                 continue
#             elif new_interval[0] >= intervals[i][1]:
#                 continue
#             else:
#                 new_interval = [min(new_interval[0], intervals[i][0]), min(new_interval[1], intervals[i][1])]
#                 count += 1
        
#         return count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        prev_end = intervals[0][1]
        count = 0

        for start, end in intervals[1:]:
            if prev_end <= start:
                prev_end = end
            else:
                prev_end = min(prev_end, end)
                count += 1
        
        return count"
,Meeting Rooms,Easy,Intervals,"Meeting Rooms
Solved 
Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), determine if a person could add all meetings to their schedule without any conflicts.

Example 1:

Input: intervals = [(0,30),(5,10),(15,20)]

Output: false
Explanation:

(0,30) and (5,10) will conflict
(0,30) and (15,20) will conflict
Example 2:

Input: intervals = [(5,8),(9,15)]

Output: true
Note:

(0,8),(8,10) is not considered a conflict at 8
Constraints:

0 <= intervals.length <= 500
0 <= intervals[i].start < intervals[i].end <= 1,000,000","""""""
Definition of Interval:
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
""""""

class Solution:
    def canAttendMeetings(self, intervals: List[Interval]) -> bool:
        intervals.sort(key=lambda x: x.start)
        prev = 0
        for curr in range(1, len(intervals)):
            if intervals[prev].end > intervals[curr].start:
                return False
            else:
                prev = curr
        return True"
,Meeting Rooms II,Medium,Intervals,"Meeting Rooms II
Solved 
Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), find the minimum number of days required to schedule all meetings without any conflicts.

Note: (0,8),(8,10) is not considered a conflict at 8.

Example 1:

Input: intervals = [(0,40),(5,10),(15,20)]

Output: 2
Explanation:
day1: (0,40)
day2: (5,10),(15,20)

Example 2:

Input: intervals = [(4,9)]

Output: 1
Constraints:

0 <= intervals.length <= 500
0 <= intervals[i].start < intervals[i].end <= 1,000,000","""""""
Definition of Interval:
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
""""""

class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        start = [i.start for i in intervals]
        end = [i.end for i in intervals]
        start.sort()
        end.sort()

        count = 0
        max_at_the_same_time = 0

        start_pointer = 0
        end_pointer = 0

        while start_pointer < len(intervals):
            if start[start_pointer] < end[end_pointer]:
                count += 1
                start_pointer += 1
            else: 
                end_pointer += 1
                count -= 1
            
            max_at_the_same_time = max(max_at_the_same_time, count)

        return max_at_the_same_time

        "
,Excel Sheet Column Title,Easy,Math & Geometry,"Excel Sheet Column Title
Solved
Easy
Topics
premium lock icon
Companies
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 

Example 1:

Input: columnNumber = 1
Output: ""A""
Example 2:

Input: columnNumber = 28
Output: ""AB""
Example 3:

Input: columnNumber = 701
Output: ""ZY""
 

Constraints:

1 <= columnNumber <= 231 - 1","class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = """"
        while columnNumber > 0:
            remainder = (columnNumber-1) %26
            res = chr(ord('A')+remainder) + res
            columnNumber = (columnNumber-1) //26
        return res"
,Greatest Common Divisor of Strings,Easy,Math & Geometry,"Greatest Common Divisor of Strings
Solved
Easy
Topics
premium lock icon
Companies
Hint
For two strings s and t, we say ""t divides s"" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).

Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

 

Example 1:

Input: str1 = ""ABCABC"", str2 = ""ABC""
Output: ""ABC""
Example 2:

Input: str1 = ""ABABAB"", str2 = ""ABAB""
Output: ""AB""
Example 3:

Input: str1 = ""LEET"", str2 = ""CODE""
Output: """"
 

Constraints:

1 <= str1.length, str2.length <= 1000
str1 and str2 consist of English uppercase letters.","class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        len1 = len(str1)
        len2 = len(str2)

        def is_Divisor(str_len):
            if len1 % str_len != 0 or len2 % str_len != 0:
                return False
            str1_num_of_repeats = len1//str_len
            str2_num_of_repeats = len2//str_len
            return ((str1[:str_len] * str1_num_of_repeats) == str1) and ((str1[:str_len] * str2_num_of_repeats) == str2)
        
        for i in range(min(len1, len2), 0, -1):
            if is_Divisor(i):
                return str1[:i]
        
        return """""
,Transpose Matrix,Easy,Math & Geometry,"Transpose Matrix
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.



 

Example 1:

Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
Example 2:

Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
-109 <= matrix[i][j] <= 109","class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        tm = [[0 for _ in range(len(matrix))] for _ in range(len(matrix[0]))]
        # print(f""tm: {tm}"")
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                tm[j][i] = matrix[i][j]
        
        return tm"
,Rotate Image,Medium,Math & Geometry,"Rotate Image
Solved 
Given a square n x n matrix of integers matrix, rotate it by 90 degrees clockwise.

You must rotate the matrix in-place. Do not allocate another 2D matrix and do the rotation.

Example 1:



Input: matrix = [
  [1,2],
  [3,4]
]

Output: [
  [3,1],
  [4,2]
]
Example 2:



Input: matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]

Output: [
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000","# class Solution:
#     def rotate(self, matrix: List[List[int]]) -> None:
#         n = len(matrix)
#         m = len(matrix[0])

#         print(f""before: {matrix}"")
#         for i in range(n):
#             for j in range(i, m):
#                 matrix[i][j], matrix[j][i]= matrix[j][i], matrix[i][j]
#         print(f""after: {matrix}"")

#         for i in range(n):
#             left = 0
#             right = m - 1
#             while left < right:
#                 matrix[i][left], matrix[i][right]= matrix[i][right], matrix[i][left]
#                 left += 1
#                 right -= 1

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        m = len(matrix[0])

        for i in range(n):
            for j in range(m):
                if i + j < n - 1:
                    matrix[i][j], matrix[n - 1 - j][n - 1 - i] = matrix[n - 1 - j][n - 1 - i], matrix[i][j]

        left = 0
        right = m - 1
        while left < right:
            matrix[left], matrix[right]= matrix[right], matrix[left]
            left += 1
            right -= 1

# before: [[1, 2, 3], 
#          [4, 5, 6], 
#          [7, 8, 9]]

# after: [[1, 4, 7], 
#         [2, 5, 8], 
#         [3, 6, 9]]

# after: [[9, 6, 3], 
#         [8, 5, 2], 
#         [7, 4, 1]]"
,Spiral Matrix,Medium,Math & Geometry,"Spiral Matrix
Solved 
Given an m x n matrix of integers matrix, return a list of all elements within the matrix in spiral order.

Example 1:



Input: matrix = [[1,2],[3,4]]

Output: [1,2,4,3]
Example 2:



Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]

Output: [1,2,3,6,9,8,7,4,5]
Example 3:

Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]

Output: [1,2,3,4,8,12,11,10,9,5,6,7]
Constraints:

1 <= matrix.length, matrix[i].length <= 10
-100 <= matrix[i][j] <= 100","class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        n = len(matrix)
        m = len(matrix[0])

        left = 0
        right = m
        bottom = 0
        up = n

        ans = []
        while left < right and bottom < up:
            for i in range(left, right):
                ans.append(matrix[bottom][i])
            bottom += 1

            for i in range(bottom, up):
                ans.append(matrix[i][right-1])
            right -= 1

            if left >= right or bottom >= up:
                break
                
            for i in range(right-1, left-1, -1):
                ans.append(matrix[up-1][i])
            up -= 1


            for i in range(up -1, bottom -1, -1):
                ans.append(matrix[i][left])
            left += 1

        return ans"
,Set Matrix Zeroes,Medium,Math & Geometry,"Set Matrix Zeroes
Solved 
Given an m x n matrix of integers matrix, if an element is 0, set its entire row and column to 0's.

You must update the matrix in-place.

Follow up: Could you solve it using O(1) space?

Example 1:



Input: matrix = [
  [0,1],
  [1,0]
]

Output: [
  [0,0],
  [0,0]
]
Example 2:



Input: matrix = [
  [1,2,3],
  [4,0,5],
  [6,7,8]
]

Output: [
  [1,0,3],
  [0,0,0],
  [6,0,8]
]
Constraints:

1 <= matrix.length, matrix[0].length <= 100
-2^31 <= matrix[i][j] <= (2^31) - 1","class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        num_rows = len(matrix)
        num_cols = len(matrix[0])

        is_first_row_zero = 1
        
        for i in range(num_rows):
            for j in range(num_cols):
                if matrix[i][j] == 0:
                    if i == 0:
                        is_first_row_zero = 0
                    else:
                        matrix[i][0] = 0
                        matrix[0][j] = 0


        is_first_col_zero = matrix[0][0]
        for i in range(num_rows-1, 0, -1):
            for j in range(num_cols-1, -1, -1): 
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        

        if is_first_row_zero == 0:
            for j in range(num_cols):
                matrix[0][j] = 0        
        
        "
,Happy Number,Easy,Math & Geometry,"Non-Cyclical Number
Solved 
A non-cyclical number is an integer defined by the following algorithm:

Given a positive integer, replace it with the sum of the squares of its digits.
Repeat the above step until the number equals 1, or it loops infinitely in a cycle which does not include 1.
If it stops at 1, then the number is a non-cyclical number.
Given a positive integer n, return true if it is a non-cyclical number, otherwise return false.

Example 1:

Input: n = 100

Output: true
Explanation: 1^2 + 0^2 + 0^2 = 1

Example 2:

Input: n = 101

Output: false
Explanation:
1^2 + 0^2 + 1^2 = 2
2^2 = 4
4^2 = 16
1^2 + 6^2 = 37
3^2 + 7^2 = 58
5^2 + 8^2 = 89
8^2 + 9^2 = 145
1^2 + 4^2 + 5^2 = 42
4^2 + 2^2 = 20
2^2 + 0^2 = 4 (This number has already been seen)

Constraints:

1 <= n <= 1000","class Solution:
    def isHappy(self, n: int) -> bool:
        visit = defaultdict(bool)

        while visit[n] == False:
            visit[n] = True
            n = self.sumOfSquares(n)
            if n == 1:
                return True
        return False

    def sumOfSquares(self, n: int) -> int:
        output = 0

        while n:
            digit = n % 10
            digit = digit ** 2
            output += digit
            n = n // 10
        return output"
,Plus One,Easy,Math & Geometry,"Plus One
Solved 
You are given an integer array digits, where each digits[i] is the ith digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.

Return the digits of the given integer after incrementing it by one.

Example 1:

Input: digits = [1,2,3,4]

Output: [1,2,3,5]
Explanation 1234 + 1 = 1235.

Example 2:

Input: digits = [9,9,9]

Output: [1,0,0,0]
Constraints:

1 <= digits.length <= 100
0 <= digits[i] <= 9","class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        next_power = [1]
        carry = 1
        for i in range(n-1,-1,-1):
            new_digit = digits[i] + carry

            remainder = new_digit % 10
            carry = new_digit // 10
            digits[i] = remainder
        
        if carry == 1:
            return next_power + digits
        return digits"
,Roman to Integer,Easy,Math & Geometry,"Roman to Integer
Solved 
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
You are given a roman numeral as a string s, convert it to an integer.

Example 1:

Input: s = ""III""

Output: 3
Example 2:

Input: s = ""XLIX""

Output: 49
Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].","class Solution:
    def romanToInt(self, s: str) -> int:
        roman = {
            ""I"": 1, ""V"": 5, ""X"": 10,
            ""L"": 50, ""C"": 100, ""D"": 500, ""M"": 1000
        }
        res = 0
        for i in range(len(s)):
            if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:
                res -= roman[s[i]]
            else:
                res += roman[s[i]]
        return res"
,"Pow(x, n)",Medium,Math & Geometry,"Pow(x, n)
Solved 
Pow(x, n) is a mathematical function to calculate the value of x raised to the power of n (i.e., x^n).

Given a floating-point value x and an integer value n, implement the myPow(x, n) function, which calculates x raised to the power n.

You may not use any built-in library functions.

Example 1:

Input: x = 2.00000, n = 5

Output: 32.00000
Example 2:

Input: x = 1.10000, n = 10

Output: 2.59374
Example 3:

Input: x = 2.00000, n = -3

Output: 0.12500
Constraints:

-100.0 < x < 100.0
-1000 <= n <= 1000
n is an integer.
If x = 0, then n will be positive.","class Solution:
    def myPow(self, x: float, n: int) -> float:
        num = 1
        is_positive = n >= 0

        for i in range(abs(n)):
            if is_positive:
                num *= x
            else:
                num /= x
        return num
        "
,Multiply Strings,Medium,Math & Geometry,"Multiply Strings
Solved 
You are given two strings num1 and num2 that represent non-negative integers.

Return the product of num1 and num2 in the form of a string.

Assume that neither num1 nor num2 contain any leading zero, unless they are the number 0 itself.

Note: You can not use any built-in library to convert the inputs directly into integers.

Example 1:

Input: num1 = ""3"", num2 = ""4""

Output: ""12""
Example 2:

Input: num1 = ""111"", num2 = ""222""

Output: ""24642""
Constraints:

1 <= num1.length, num2.length <= 200
num1 and num2 consist of digits only.","class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == ""0"" or num2 == ""0"":
            return ""0""
        
        res = [0] * (len(num1) + len(num2))
        num1 = num1[::-1]
        num2 = num2[::-1]
        
        for i in range(len(num1)):
            for j in range(len(num2)): 
                digit = int(num1[i]) * int(num2[j])
                res[i+j] += digit
                remainder = res[i+j] % 10
                carry = res[i+j] // 10
                res[i+j] = remainder
                res[i+j+1] += carry

        ans = """"
        for val in res[::-1]:
            if ans == """" and val == 0:
                continue
            ans += str(val)
        return ans"
,Detect Squares,Medium,Math & Geometry,"Detect Squares
Solved 
You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:

Add - new points can be added to the stream into a data structure. Duplicate points are allowed and should be treated as separate points.
Query - Given a single query point, count the number of ways to choose three additional points from the data structure such that the three points and the query point form a square. The square must have all sides parallel to the x-axis and y-axis, i.e. no diagonal squares are allowed. Recall that a square must have four equal sides.
Implement the CountSquares class:

CountSquares() Initializes the object.
void add(int[] point) Adds a new point point = [x, y].
int count(int[] point) Counts the number of ways to form valid squares with point point = [x, y] as described above.
Example 1:



Input: 
[""CountSquares"", ""add"", [[1, 1]], ""add"", [[2, 2]], ""add"", [[1, 2]], ""count"", [[2, 1]], ""count"", [[3, 3]], ""add"", [[2, 2]], ""count"", [[2, 1]]]
       
Output:
[null, null, null, null, 1, 0, null, 2]

Explanation:
CountSquares countSquares = new CountSquares();
countSquares.add([1, 1]);
countSquares.add([2, 2]);
countSquares.add([1, 2]);

countSquares.count([2, 1]);   // return 1.
countSquares.count([3, 3]);   // return 0.
countSquares.add([2, 2]);     // Duplicate points are allowed.
countSquares.count([2, 1]);   // return 2. 
Constraints:

point.length == 2
0 <= x, y <= 1000","class CountSquares:

    def __init__(self):
        self.point_dic = defaultdict(int)
        self.point_list = []
        

    def add(self, point: List[int]) -> None:
        self.point_dic[tuple(point)] += 1
        self.point_list.append(tuple(point))
        

    def count(self, point: List[int]) -> int:
        px, py = point
        res = 0

        for point in self.point_list:
            x, y = point
            if x == px or y == py:
                continue
            if abs(px - x) != abs(py - y):
                continue
            
            res += self.point_dic[(px, y)] * self.point_dic[(x, py)]
        
        return res

        "
,Single Number,Easy,Bit Manipulation,"Single Number
Solved 
You are given a non-empty array of integers nums. Every integer appears twice except for one.

Return the integer that appears only once.

You must implement a solution with 
O
(
n
)
O(n) runtime complexity and use only 
O
(
1
)
O(1) extra space.

Example 1:

Input: nums = [3,2,3]

Output: 2
Example 2:

Input: nums = [7,6,6,7,8]

Output: 8
Constraints:

1 <= nums.length <= 10000
-10000 <= nums[i] <= 10000","class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            res = res ^ num
        return res
        "
,Number of One Bits,Easy,Bit Manipulation,"Number of One Bits
Solved 
You are given an unsigned integer n. Return the number of 1 bits in its binary representation.

You may assume n is a non-negative integer which fits within 32-bits.

Example 1:

Input: n = 00000000000000000000000000010111

Output: 4
Example 2:

Input: n = 01111111111111111111111111111101

Output: 30","class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n != 0:
            res += n%2
            # n = n//2
            n = n >> 1 # this is almost the same as n = n//2
        
        return res"
,Counting Bits,Easy,Bit Manipulation,"Counting Bits
Solved 
Given an integer n, count the number of 1's in the binary representation of every number in the range [0, n].

Return an array output where output[i] is the number of 1's in the binary representation of i.

Example 1:

Input: n = 4

Output: [0,1,1,2,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100

Constraints:

0 <= n <= 1000","class Solution:
    def countBits(self, n: int) -> List[int]:
        res = []
        for i in range(n+1):
            count = 0
            m = i
            while m != 0:
                count += m%2
                m = m >> 1
            res.append(count)
        return res
            "
,Reverse Bits,Easy,Bit Manipulation,"Reverse Bits
Solved 
Given a 32-bit unsigned integer n, reverse the bits of the binary representation of n and return the result.

Example 1:

Input: n = 00000000000000000000000000010101

Output:    2818572288 (10101000000000000000000000000000)
Explanation: Reversing 00000000000000000000000000010101, which represents the unsigned integer 21, gives us 10101000000000000000000000000000 which represents the unsigned integer 2818572288.","class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            bit = (n >> i) & 1
            # get first number & with 1 to get the bit at the last position
            # ex 5 101  we want to check what the last 1 is
            # 1 & 1 is 1
            # move value to the end of the bit ar idx 31 below and continue
            res += (bit << (31 - i))
        return res"
,Missing Number,Easy,Bit Manipulation,"Missing Number
Solved 
Given an array nums containing n integers in the range [0, n] without any duplicates, return the single number in the range that is missing from nums.

Follow-up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?

Example 1:

Input: nums = [1,2,3]

Output: 0
Explanation: Since there are 3 numbers, the range is [0,3]. The missing number is 0 since it does not appear in nums.

Example 2:

Input: nums = [0,2]

Output: 1
Constraints:

1 <= nums.length <= 1000","class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):    
            res += i+1 - nums[i]
        return res

[0,2]"
,Sum of Two Integers,Medium,Bit Manipulation,"Sum of Two Integers
Solved 
Given two integers a and b, return the sum of the two integers without using the + and - operators.

Example 1:

Input: a = 1, b = 1

Output: 2
Example 2:

Input: a = 4, b = 7

Output: 11
Constraints:

-1000 <= a, b <= 1000","class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF
        max_int = 0x7FFFFFFF

        while b != 0:
            c  = (a ^ b) & mask
            b = ((a & b) << 1) & mask
            a = c
        
        return a if a <= max_int else ~(a ^ mask)
        "
,Reverse Integer,Medium,Bit Manipulation,"Reverse Integer
Solved 
You are given a signed 32-bit integer x.

Return x after reversing each of its digits. After reversing, if x goes outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0 instead.

Solve the problem without using integers that are outside the signed 32-bit integer range.

Example 1:

Input: x = 1234

Output: 4321
Example 2:

Input: x = -1234

Output: -4321
Example 3:

Input: x = 1234236467

Output: 0
Constraints:

-2^31 <= x <= 2^31 - 1","class Solution:
    def reverse(self, x: int) -> int:
        MIN = -2147483648
        MAX = 2147483647

        res = 0
        while x != 0:
            # mode and floor divide work poorly with negative numbers in python
            # these functions help
            digit = int(math.fmod(x,10)) 
            x = int(x/10)

            if res > MAX//10 or (res == MAX//10 and digit >= MAX % 10):
                return 0
            if res < int(MIN/10) or (res == int(MIN/10) and digit <= int(math.fmod(MIN,10)) ):
                return 0
            res = res * 10 + digit

        return res"
,Concatenation of Array,Easy,Array & Hashing,"Concatenation of Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans.

 

Example 1:

Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
Example 2:

Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
 

Constraints:

n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 1000","class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums + nums
        "
,Longest Common Prefix,Easy,Array & Hashing,"Longest Common Prefix
Solved
Easy
Topics
premium lock icon
Companies
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string """".

 

Example 1:

Input: strs = [""flower"",""flow"",""flight""]
Output: ""fl""
Example 2:

Input: strs = [""dog"",""racecar"",""car""]
Output: """"
Explanation: There is no common prefix among the input strings.
 

Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters if it is non-empty.","class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) <= 1:
            return '' if len(strs) == 0 else strs[0]
        
        prefix = strs[0]
        for i in range(1, len(strs)):
            new_prefix = ''
            for j in range(min(len(prefix), len(strs[i]))):
                if strs[i][j] != prefix[j]:
                    break
                new_prefix += strs[i][j]
            prefix = new_prefix
        
        return prefix"
,Remove Element,Easy,Array & Hashing,"Remove Element
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

 

Example 1:

Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
 

Constraints:

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100","class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        last_spot = 0
        for i in range(len(nums)):
            if nums[i] == val:
                continue
            nums[last_spot] = nums[i]
            last_spot += 1
        return last_spot
            "
,Majority Element,Easy,Array & Hashing,"Majority Element
Solved
Easy
Topics
premium lock icon
Companies
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 

Constraints:

n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109
 

Follow-up: Could you solve the problem in linear time and in O(1) space?","class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        res = 0
        count = 0

        for num in nums:
            if count == 0:
                res = num
            count += 1 if res == num else -1
        
        return res"
,Design HashSet,Easy,Array & Hashing,"Design HashSet
Solved
Easy
Topics
premium lock icon
Companies
Design a HashSet without using any built-in hash table libraries.

Implement MyHashSet class:

void add(key) Inserts the value key into the HashSet.
bool contains(key) Returns whether the value key exists in the HashSet or not.
void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.
 

Example 1:

Input
[""MyHashSet"", ""add"", ""add"", ""contains"", ""contains"", ""add"", ""contains"", ""remove"", ""contains""]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
Output
[null, null, null, true, false, null, true, null, false]

Explanation
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // return True
myHashSet.contains(3); // return False, (not found)
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // return True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // return False, (already removed)
 

Constraints:

0 <= key <= 106
At most 104 calls will be made to add, remove, and contains.","class ListNode:

    def __init__(self, val):
        self.next = None
        self.val = val
        
class MyHashSet:
    def __init__(self):
        self.k = 10000
        self.arr = [ListNode(0) for _ in range(self.k)]

    def add(self, key: int) -> None:
        idx = key % self.k
        start = self.arr[idx]

        while start.next:
            if start.next.val == key:
                return
            start = start.next
        
        start.next = ListNode(val = key)


    def remove(self, key: int) -> None:
        idx = key % self.k
        start = self.arr[idx]

        while start.next:
            if start.next.val == key:
                start.next = start.next.next
                return
            start = start.next
        

    def contains(self, key: int) -> bool:
        idx = key % self.k
        start = self.arr[idx]

        while start.next:
            if start.next.val == key:
                return True
            start = start.next
        return False
    


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)"
,Design HashMap,Easy,Array & Hashing,"Design HashMap
Solved
Easy
Topics
premium lock icon
Companies
Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.
 

Example 1:

Input
[""MyHashMap"", ""put"", ""put"", ""get"", ""get"", ""put"", ""get"", ""remove"", ""get""]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
 

Constraints:

0 <= key, value <= 106
At most 104 calls will be made to put, get, and remove.","class ListNode:

    def __init__(self, val):
        self.val = val
        self.next = None

class MyHashMap:

    def __init__(self):
        self.k = 10000
        self.arr = [ListNode(None) for i in range(self.k)]

    def put(self, key: int, value: int) -> None:
        idx = key % self.k
        curr = self.arr[idx]

        while curr.next:
            if curr.next.val is not None and curr.next.val[0] == key:
                curr.next.val = [key, value]
                return
            curr = curr.next
        curr.next = ListNode([key, value])

        

    def get(self, key: int) -> int:
        idx = key % self.k
        curr = self.arr[idx]

        while curr.next:
            if curr.next.val is not None and curr.next.val[0] == key:
                return curr.next.val[1]
            curr = curr.next
        return -1
        

    def remove(self, key: int) -> None:
        idx = key % self.k
        curr = self.arr[idx]

        while curr.next:
            if curr.next.val is not None and curr.next.val[0] == key:
                curr.next = curr.next.next
                return
            curr = curr.next
        
# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)"
,Sort an Array,Medium,Array & Hashing,"Given an array of integers nums, sort the array in ascending order and return it.

You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.

 

Example 1:

Input: nums = [5,2,3,1]
Output: [1,2,3,5]
Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).
Example 2:

Input: nums = [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]
Explanation: Note that the values of nums are not necessarily unique.
 

Constraints:

1 <= nums.length <= 5 * 104
-5 * 104 <= nums[i] <= 5 * 104","class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        def merge_sort(list1, list2):
            if len(list1) == 1 and len(list2) == 0:
                return list1
            if len(list1) == 0 and len(list2) == 1:
                return list2
            if len(list1) == 1 and len(list2) == 1:
                if list1[0] < list2[0]:
                    return list1 + list2
                return list2 + list1
            
            list1_mid = len(list1)//2
            list2_mid = len(list2)//2

            sorted_list1 = merge_sort(list1[:list1_mid], list1[list1_mid:])
            sorted_list2 = merge_sort(list2[:list2_mid], list2[list2_mid:])


            p_l1 = 0
            p_l2 = 0
            sort_full_list = []
            while p_l1 < len(sorted_list1) and p_l2 < len(sorted_list2):

                if sorted_list1[p_l1] < sorted_list2[p_l2]:
                    sort_full_list.append(sorted_list1[p_l1])
                    p_l1 += 1
                else:
                     sort_full_list.append(sorted_list2[p_l2])
                     p_l2 += 1
            
            
            
            if p_l1 < len(list1):
                sort_full_list = sort_full_list + sorted_list1[p_l1:]
            if p_l2 < len(list2):
                sort_full_list = sort_full_list + sorted_list2[p_l2:]

            return sort_full_list
        
        return merge_sort(nums[:len(nums)//2], nums[len(nums)//2:])
        
# class Solution:
#     def sortArray(self, nums: List[int]) -> List[int]:
#         def merge(arr, L, M, R):
#             left, right = arr[L : M + 1], arr[M + 1 : R + 1]
#             i, j, k = L, 0, 0

#             while j < len(left) and k < len(right):
#                 if left[j] <= right[k]:
#                     arr[i] = left[j]
#                     j += 1
#                 else:
#                     arr[i] = right[k]
#                     k += 1
#                 i += 1
#             while j < len(left):
#                 nums[i] = left[j]
#                 j += 1
#                 i += 1
#             while k < len(right):
#                 nums[i] = right[k]
#                 k += 1
#                 i += 1
        
#         def mergeSort(arr, l, r):
#             if l == r:
#                 return

#             m = (l + r) // 2
#             mergeSort(arr, l, m)
#             mergeSort(arr, m + 1, r)
#             merge(arr, l, m, r)
#             return
        
#         mergeSort(nums, 0, len(nums))
#         return nums"
,Sort Colors,Medium,Array & Hashing,"Sort Colors
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

Example 1:

Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Example 2:

Input: nums = [2,0,1]
Output: [0,1,2]
 

Constraints:

n == nums.length
1 <= n <= 300
nums[i] is either 0, 1, or 2.
 

Follow up: Could you come up with a one-pass algorithm using only constant extra space?","class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""

        def merge_sort(arr, l, r):
            
            if l >= r:
                return
            
            
            m = l + (r - l)//2
            merge_sort(arr, l, m)
            merge_sort(arr, m+1, r)

            arr_pointer = l
            list1 = arr[l:m+1]
            list2 = arr[m+1:r+1]
            l1_pointer = 0
            l2_pointer = 0

            while l1_pointer < len(list1) and l2_pointer < len(list2):

                if list1[l1_pointer] <= list2[l2_pointer]:
                    arr[arr_pointer] = list1[l1_pointer]
                    l1_pointer += 1
                else:
                    arr[arr_pointer] = list2[l2_pointer]
                    l2_pointer += 1
                arr_pointer += 1
            

            while l1_pointer < len(list1):
                arr[arr_pointer] = list1[l1_pointer]
                l1_pointer += 1
                arr_pointer += 1
            
            while l2_pointer < len(list2):
                arr[arr_pointer] = list2[l2_pointer]
                l2_pointer += 1
                arr_pointer += 1
            
            
            return
        
        merge_sort(nums, 0, len(nums)-1)


        "
,Range Sum Query 2D - Immutable,Medium,Array & Hashing,"Range Sum Query 2D - Immutable
Solved
Medium
Topics
premium lock icon
Companies
Given a 2D matrix matrix, handle multiple queries of the following type:

Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:

NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.
int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
You must design an algorithm where sumRegion works on O(1) time complexity.

 

Example 1:


Input
[""NumMatrix"", ""sumRegion"", ""sumRegion"", ""sumRegion""]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
-104 <= matrix[i][j] <= 104
0 <= row1 <= row2 < m
0 <= col1 <= col2 < n
At most 104 calls will be made to sumRegion.","class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix = matrix[:]
        self.matrix_sum = matrix[:]
        self.n = len(self.matrix)
        self.m = len(self.matrix[0])
        
        row_total = 0
        for i in range(self.n):
            row_total += self.matrix[i][0]
            self.matrix_sum[i][0] = row_total

        col_total = 0
        # print(f""self.m: {self.m}"")
        for j in range(self.m):
            # print(f""j: {j}"")
            col_total += self.matrix[0][j]
            self.matrix_sum[0][j] = col_total
        
        for i in range(1, self.n):
            for j in range(1, self.m):
                self.matrix_sum[i][j] = self.matrix_sum[i-1][j] + self.matrix_sum[i][j-1] + self.matrix[i][j] -  self.matrix_sum[i-1][j-1]
        


    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        subtract_one = 0
        if row1 > 0:
            subtract_one = self.matrix_sum[row1-1][col2]

        subtract_two = 0
        if col1 > 0:
            subtract_two = self.matrix_sum[row2][col1-1]
        
        add_one = 0
        if row1 > 0 and col1 > 0:
            add_one = self.matrix_sum[row1 -1][col1-1]
        
        return self.matrix_sum[row2][col2] - subtract_one - subtract_two + add_one


        # Idea sum all squares from to top left to bottom right

        # Get sum in bottom right

        # Get square sum from row1 -1, col2 and row2, col1-1

        # add square of sum of row1 -1, col - 1
        
        


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)

[
    [3, 3, 4, 8, 10], 
    [8, 17, 24, 34, 45], 
    [9, 28, 52, 87, 137], 
    [13, 42, 94, 182, 326], 
    [14, 56, 153, 335, 666]]"
,Best Time to Buy and Sell Stock II,Medium,Array & Hashing,"        Best Time to Buy and Sell Stock II
Solved
Medium
Topics
premium lock icon
Companies
You are given an integer array prices where prices[i] is the price of a given stock on the ith day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.

Find and return the maximum profit you can achieve.

 

Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
Example 2:

Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
Example 3:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
 

Constraints:

1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104","class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)

        if n < 2:
            return 0
        
        min_value = 0
        total = 0
        for i in range(1,n):
            profit = prices[i] - prices[i-1]

            if profit >= 0:
                total += profit

        return total"
,Majority Element II,Medium,Array & Hashing,"Majority Element II
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

 

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 

Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109
 

Follow up: Could you solve the problem in linear time and in O(1) space?","class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        n = len(nums)
        target = n // 3

        count_dic = defaultdict(int)
        nums_pointer = 0

        for i in range(len(nums)):
            num = nums[i]
            count_dic[num] += 1

            if count_dic[num] == target+1:
                nums[nums_pointer] = num
                nums_pointer += 1
        return nums[:nums_pointer]
        "
,Subarray Sum Equals K,Medium,Array & Hashing,"Subarray Sum Equals K
Solved
Medium
Topics
premium lock icon
Companies
Hint
Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
Example 2:

Input: nums = [1,2,3], k = 3
Output: 2
 

Constraints:

1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107","# class Solution:
#     def subarraySum(self, nums: List[int], k: int) -> int:
#         count = 0
#         l = 0
#         r = 0
#         total = 0
#         while r < len(nums):
#             total += nums[r]

#             if total >= k:
#                 if total == k:
#                     count += 1
#                 total -= nums[l]
#                 l += 1
#             r += 1
        
#         return count



class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        res = curSum = 0
        prefixSums = { 0 : 1 }

        for num in nums:
            curSum += num
            diff = curSum - k

            res += prefixSums.get(diff, 0)
            prefixSums[curSum] = 1 + prefixSums.get(curSum, 0)
        
        return res"
,Reverse String,Easy,Two Pointer,"Reverse String
Solved
Easy
Topics
premium lock icon
Companies
Hint
Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

 

Example 1:

Input: s = [""h"",""e"",""l"",""l"",""o""]
Output: [""o"",""l"",""l"",""e"",""h""]
Example 2:

Input: s = [""H"",""a"",""n"",""n"",""a"",""h""]
Output: [""h"",""a"",""n"",""n"",""a"",""H""]
 

Constraints:

1 <= s.length <= 105
s[i] is a printable ascii character.","class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        left = 0
        right = len(s) - 1

        while left < right:
            s[left], s[right] = s[right], s[left]
            right -= 1
            left += 1
            "
,Valid Palindrome II,Easy,Two Pointer,"Valid Palindrome II
Solved
Easy
Topics
premium lock icon
Companies
Given a string s, return true if the s can be palindrome after deleting at most one character from it.

 

Example 1:

Input: s = ""aba""
Output: true
Example 2:

Input: s = ""abca""
Output: true
Explanation: You could delete the character 'c'.
Example 3:

Input: s = ""abc""
Output: false
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.","class Solution:
    def validPalindrome(self, s: str) -> bool:
        def is_palindrome(left, right):
            while left < right:
                if s[left] != s[right]:
                    return False
                left += 1
                right -= 1
            return True
        
        left = 0
        right = len(s)-1

        while left < right:
            if s[left] != s[right]:
                return is_palindrome(left + 1, right) or is_palindrome(left, right-1)
            
            left += 1
            right -= 1
        return True"
,Merge Strings Alternately,Easy,Two Pointer,"Merge Strings Alternately
Solved
Easy
Topics
premium lock icon
Companies
Hint
You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

 

Example 1:

Input: word1 = ""abc"", word2 = ""pqr""
Output: ""apbqcr""
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
Example 2:

Input: word1 = ""ab"", word2 = ""pqrs""
Output: ""apbqrs""
Explanation: Notice that as word2 is longer, ""rs"" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
Example 3:

Input: word1 = ""abcd"", word2 = ""pq""
Output: ""apbqcd""
Explanation: Notice that as word1 is longer, ""cd"" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
 

Constraints:

1 <= word1.length, word2.length <= 100
word1 and word2 consist of lowercase English letters.","class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        n = len(word1)
        m = len(word2)

        i = 0
        j = 0
        
        ans = """"
        while i < n and j < m:
            ans += word1[i] + word2[j]
            i += 1
            j+= 1
        
        if i < n:
            ans += word1[i:]
        
        if j < m:
            ans += word2[j:]
        
        return ans

        "
,Merge Sorted Array,Easy,Two Pointer,"Merge Sorted Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

 

Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
Example 2:

Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
Example 3:

Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
 

Constraints:

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
 

Follow up: Can you come up with an algorithm that runs in O(m + n) time?","class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """"""
        Do not return anything, modify nums1 in-place instead.
        """"""
        
        ans_pointer = m + n - 1
        nums1_pointer = m - 1
        nums2_pointer = n - 1

        while nums1_pointer >= 0 and nums2_pointer >= 0:

            n1_val = nums1[nums1_pointer]
            n2_val = nums2[nums2_pointer]

            if n2_val > n1_val:
                nums1[ans_pointer] = n2_val
                nums2_pointer -= 1
            else:
                nums1[ans_pointer] = n1_val
                nums1_pointer -= 1
                
            ans_pointer -= 1
        
        if nums1_pointer >= 0:
            while ans_pointer >= 0:
                nums1[ans_pointer] = nums1[nums1_pointer]
                nums1_pointer -= 1
                ans_pointer -= 1
        
        if nums2_pointer >= 0:
            while ans_pointer >= 0:
                nums1[ans_pointer] = nums2[nums2_pointer]
                nums2_pointer -= 1
                ans_pointer -= 1"
,Remove Duplicates from Sorted Array,Easy,Two Pointer,"Remove Duplicates from Sorted Array
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

 

Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
 

Constraints:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.","class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        insert_pointer = 0

        for i in range(len(nums)):
            if i >0 and nums[i] == nums[i-1]:
                continue
            nums[insert_pointer] = nums[i]
            insert_pointer += 1
        
        return insert_pointer
        "
,Contains Duplicate II,Easy,Sliding Window,"Contains Duplicate II
Solved
Easy
Topics
premium lock icon
Companies
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

 

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105","class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        dic = defaultdict(lambda: -1)

        
        for i in range(len(nums)):
            val = nums[i]
            if dic[val] != -1:
                if (i - dic[val]) <= k:
                    return True
            dic[val] = i
        return False"
,Find K Closest Elements,Medium,Sliding Window,"Find K Closest Elements
Solved
Medium
Topics
premium lock icon
Companies
Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.

An integer a is closer to x than an integer b if:

|a - x| < |b - x|, or
|a - x| == |b - x| and a < b
 

Example 1:

Input: arr = [1,2,3,4,5], k = 4, x = 3

Output: [1,2,3,4]

Example 2:

Input: arr = [1,1,2,3,4,5], k = 4, x = -1

Output: [1,1,2,3]

 

Constraints:

1 <= k <= arr.length
1 <= arr.length <= 104
arr is sorted in ascending order.
-104 <= arr[i], x <= 104","# import heapq as hq
# class Solution:
#     def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
#         pq = []


#         for i in range(len(arr)):
#             if len(pq) < k:
#                 hq.heappush(pq, (-1 * abs(x - arr[i]),arr[i]))
#             else:
#                 difference, val = pq[0]
#                 if difference < (-1 * abs(x - arr[i])):
#                     hq.heappop(pq)
#                     hq.heappush(pq, (-1 * abs(x - arr[i]),arr[i]))
#         res = []
#         while pq:
#             res.append(hq.heappop(pq)[1])
#         res.sort()
#         return res

class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - 1
        while r - l >= k:
            if abs(x - arr[l]) <= abs(x - arr[r]):
                r -= 1
            else:
                l += 1
        
        return arr[l: r + 1]"
,Minimum Size Subarray Sum,Medium,Sliding Window,"Minimum Size Subarray Sum
Solved
Medium
Topics
premium lock icon
Companies
Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

 

Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1
Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
 

Constraints:

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
 

Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).","class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        n = len(nums)
        total = nums[0]
        min_len = 10000000
        while right < n:
            print(f""right: {right}, total: {total}"")

            if total < target:
                right += 1
                if right < n:
                    total += nums[right]
            else:
                min_len = min(min_len, (right-left + 1))
                total -= nums[left]
                left += 1
            
        return 0 if min_len == 10000000 else min_len"
,Baseball Game,Easy,Stack,"Baseball Game
Solved
Easy
Topics
premium lock icon
Companies
You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.

You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:

An integer x.
Record a new score of x.
'+'.
Record a new score that is the sum of the previous two scores.
'D'.
Record a new score that is the double of the previous score.
'C'.
Invalidate the previous score, removing it from the record.
Return the sum of all the scores on the record after applying all the operations.

The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.

 

Example 1:

Input: ops = [""5"",""2"",""C"",""D"",""+""]
Output: 30
Explanation:
""5"" - Add 5 to the record, record is now [5].
""2"" - Add 2 to the record, record is now [5, 2].
""C"" - Invalidate and remove the previous score, record is now [5].
""D"" - Add 2 * 5 = 10 to the record, record is now [5, 10].
""+"" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
Example 2:

Input: ops = [""5"",""-2"",""4"",""C"",""D"",""9"",""+"",""+""]
Output: 27
Explanation:
""5"" - Add 5 to the record, record is now [5].
""-2"" - Add -2 to the record, record is now [5, -2].
""4"" - Add 4 to the record, record is now [5, -2, 4].
""C"" - Invalidate and remove the previous score, record is now [5, -2].
""D"" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
""9"" - Add 9 to the record, record is now [5, -2, -4, 9].
""+"" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
""+"" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
Example 3:

Input: ops = [""1"",""C""]
Output: 0
Explanation:
""1"" - Add 1 to the record, record is now [1].
""C"" - Invalidate and remove the previous score, record is now [].
Since the record is empty, the total sum is 0.
 

Constraints:

1 <= operations.length <= 1000
operations[i] is ""C"", ""D"", ""+"", or a string representing an integer in the range [-3 * 104, 3 * 104].
For operation ""+"", there will always be at least two previous scores on the record.
For operations ""C"" and ""D"", there will always be at least one previous score on the record.","class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack = []

        for op in operations:
            if op == ""C"":
                stack.pop()
            elif op == ""D"":
                val = stack[-1]
                stack.append(2 * val)
            elif op == ""+"":
                val = stack[-1]
                val2 = stack[-2]
                stack.append(val+val2)
            else:
                stack.append(int(op))
        
        return 0 if len(stack) == 0 else sum(stack)"
,Implement Stack Using Queues,Easy,Stack,"Implement Stack using Queues
Solved
Easy
Topics
premium lock icon
Companies
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).

Implement the MyStack class:

void push(int x) Pushes element x to the top of the stack.
int pop() Removes the element on the top of the stack and returns it.
int top() Returns the element on the top of the stack.
boolean empty() Returns true if the stack is empty, false otherwise.
Notes:

You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.
 

Example 1:

Input
[""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, top, and empty.
All the calls to pop and top are valid.
 

Follow-up: Can you implement the stack using only one queue?","class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()
        

    def push(self, x: int) -> None:
        self.q1.append(x)
        

    def pop(self) -> int:
        for i in range(len(self.q1)-1):
            self.q2.append(self.q1.popleft())
        val = self.q1[0]
        self.q1 = self.q2
        self.q2 = deque()
        return val

        

    def top(self) -> int:
        return self.q1[-1]
        

    def empty(self) -> bool:
        return len(self.q1) == 0
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()"
,Implement Queue using Stacks,Easy,Stack,"Implement Queue using Stacks
Solved
Easy
Topics
premium lock icon
Companies
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
 

Example 1:

Input
[""MyQueue"", ""push"", ""push"", ""peek"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, peek, and empty.
All the calls to pop and peek are valid.
 

Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.","class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []
        

    def push(self, x: int) -> None:
        self.s1.append(x)
        

    def pop(self) -> int:
        for i in range(len(self.s1)-1):
            self.s2.append(self.s1.pop())
        val = self.s1[0]
        self.s1 = []
        for i in range(len(self.s2)):
            self.s1.append(self.s2.pop())


        return val
        

    def peek(self) -> int:
        return self.s1[0]
        

    def empty(self) -> bool:
        return len(self.s1) == 0
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()"
,Asteroid Collision,Medium,Stack,"Asteroid Collision
Solved
Medium
Topics
premium lock icon
Companies
Hint
We are given an array asteroids of integers representing asteroids in a row. The indices of the asteriod in the array represent their relative position in space.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

 

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:

Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:

Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
 

Constraints:

2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0","class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = [asteroids[0]]

        for i in range(1, len(asteroids)):
            if len(stack) == 0:
                stack.append(asteroids[i])
                continue
            meteor1 = stack.pop()
            meteor2 = asteroids[i]

            if meteor1 > 0 and meteor2 < 0:
                if abs(meteor2) > abs(meteor1):
                    remaining_meteor = meteor2
                elif abs(meteor2) < abs(meteor1):
                    remaining_meteor = meteor1
                else:
                    remaining_meteor = 0

                while remaining_meteor < 0 and len(stack) != 0 and stack[-1] > 0:
                    meteor3 = stack.pop()
                    if abs(remaining_meteor) > abs(meteor3):
                        remaining_meteor = remaining_meteor
                    elif abs(remaining_meteor) < abs(meteor3):
                        remaining_meteor = meteor3
                    else: 
                        remaining_meteor = 0

                if remaining_meteor != 0:
                    stack.append(remaining_meteor)
            else:
                stack.append(meteor1)
                stack.append(meteor2)
        
        return stack
        "
,Online Stock Span,Medium,Stack,"Online Stock Span
Solved
Medium
Topics
premium lock icon
Companies
Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.

The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.

For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.
Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.
Implement the StockSpanner class:

StockSpanner() Initializes the object of the class.
int next(int price) Returns the span of the stock's price given that today's price is price.
 

Example 1:

Input
[""StockSpanner"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next""]
[[], [100], [80], [60], [70], [60], [75], [85]]
Output
[null, 1, 1, 1, 2, 1, 4, 6]

Explanation
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.
stockSpanner.next(85);  // return 6
 

Constraints:

1 <= price <= 105
At most 104 calls will be made to next.","# class StockSpanner:

#     def __init__(self):
#         self.stack1 = []
#         self.stack2 = []
#         self.memo = {}
        

#     def next(self, price: int) -> int:
#         count = 1
        
#         while self.stack1 and self.stack1[-1] <= price:
#             self.stack2.append(self.stack1.pop())
#             count += 1
        
#         for i in range(len(self.stack2)):
#             self.stack1.append(self.stack2.pop())
#         self.stack1.append(price)

#         self.memo[len(self.stack1)] = count
            
#         return count


# class StockSpanner:

#     def __init__(self):
#         self.stack1 = []
#         self.memo = []
        

#     def next(self, price: int) -> int:
#         count = 1
        
#         if len(self.stack1) == 0 or self.stack1[-1] > price:
#             self.stack1.append(price)
#             return count
        
        
#         for i in range(1, len(self.stack1)+1):
#             if (len(self.stack1)-i) < 0 or (self.stack1[len(self.stack1)-i] > price):
#                 self.stack1.append(price)
#                 return count

#             count += 1
#         self.stack1.append(price)
#         return count
        
#neetcode solution
# The trick is if you pop a value you never need to look at it again you only need to look at the potential next biggest value which is why a stack works
class StockSpanner:

    def __init__(self):
        self.stack = []  # pair: (price, span)

    def next(self, price: int) -> int:
        span = 1
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack[-1][1]
            self.stack.pop()
        self.stack.append((price, span))
        return span

# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)"
,Simplify Path,Medium,Stack,"Simplify Path
Solved
Medium
Topics
premium lock icon
Companies
You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.

The rules of a Unix-style file system are as follows:

A single period '.' represents the current directory.
A double period '..' represents the previous/parent directory.
Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'.
Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names.
The simplified canonical path should follow these rules:

The path must start with a single slash '/'.
Directories within the path must be separated by exactly one slash '/'.
The path must not end with a slash '/', unless it is the root directory.
The path must not have any single or double periods ('.' and '..') used to denote current or parent directories.
Return the simplified canonical path.

 

Example 1:

Input: path = ""/home/""

Output: ""/home""

Explanation:

The trailing slash should be removed.

Example 2:

Input: path = ""/home//foo/""

Output: ""/home/foo""

Explanation:

Multiple consecutive slashes are replaced by a single one.

Example 3:

Input: path = ""/home/user/Documents/../Pictures""

Output: ""/home/user/Pictures""

Explanation:

A double period "".."" refers to the directory up a level (the parent directory).

Example 4:

Input: path = ""/../""

Output: ""/""

Explanation:

Going one level up from the root directory is not possible.

Example 5:

Input: path = ""/.../a/../b/c/../d/./""

Output: ""/.../b/d""

Explanation:

""..."" is a valid name for a directory in this problem.

 

Constraints:

1 <= path.length <= 3000
path consists of English letters, digits, period '.', slash '/' or '_'.
path is a valid absolute Unix path.","class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        paths = path.split(""/"")

        print(paths)
        for cur in paths:
            if stack and cur == "".."":
                stack.pop()
                continue
            if cur == '.':
                continue
            if cur != """" and cur != "".."":
                stack.append(cur)
        print(stack)
        return '/' + ""/"".join(stack)"
,Decode String,Medium,Stack,"Decode String
Solved
Medium
Topics
premium lock icon
Companies
Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

The test cases are generated so that the length of the output will never exceed 105.

 

Example 1:

Input: s = ""3[a]2[bc]""
Output: ""aaabcbc""
Example 2:

Input: s = ""3[a2[c]]""
Output: ""accaccacc""
Example 3:

Input: s = ""2[abc]3[cd]ef""
Output: ""abcabccdcdcdef""
 

Constraints:

1 <= s.length <= 30
s consists of lowercase English letters, digits, and square brackets '[]'.
s is guaranteed to be a valid input.
All the integers in s are in the range [1, 300].","class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        res = ''
        for i in range(len(s)):
            if s[i] == ""]"":
                concat_str = ''
                while stack and stack[-1] != '[':
                    concat_str = stack.pop() + concat_str
                print(concat_str)
                if stack and stack[-1] == '[':
                    stack.pop()
                    get_multiplier = ''
                    while stack and stack[-1] in ['0','1','2','3','4','5','6','7','8','9']:
                        get_multiplier = stack.pop() + get_multiplier
                    
                    stack.append(int(get_multiplier) * concat_str)
            else:
                stack.append(s[i])
            
        return """".join(stack)"
,Search Insert Position,Easy,Binary Search,"Search Insert Position
Solved
Easy
Topics
premium lock icon
Companies
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4
 

Constraints:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104","class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)

        while left < right:
            mid = left + (right - left)//2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid
            
        return left"
,Guess Number Higher Or Lower,Easy,Binary Search,"Guess Number Higher or Lower
Solved
Easy
Topics
premium lock icon
Companies
We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

 

Example 1:

Input: n = 10, pick = 6
Output: 6
Example 2:

Input: n = 1, pick = 1
Output: 1
Example 3:

Input: n = 2, pick = 1
Output: 1
 

Constraints:

1 <= n <= 231 - 1
1 <= pick <= n","# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        left = 1
        right = n

        while left < right:
            mid = left + (right - left) // 2
            guess_val = guess(mid)

            if guess_val == -1:
                right = mid
            elif guess_val == 1:
                left = mid + 1
            else:
                return mid

        return right
        "
,Sqrt(x),Easy,Binary Search,"Sqrt(x)
Solved
Easy
Topics
premium lock icon
Companies
Hint
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
 

Example 1:

Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.
Example 2:

Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
 

Constraints:

0 <= x <= 231 - 1","class Solution:
    def mySqrt(self, x: int) -> int:
        if x <=1:
            return x
        left = 0
        right = x
        res = 0

        while left < right:
            mid = left + (right - left)//2
            sqr = mid**2


            if sqr == x:
                return mid
            elif sqr < x:
                left = mid + 1
                res = mid
            else:
                right = mid
        
        return res

# class Solution:
#     def mySqrt(self, x: int) -> int:
#         l, r = 0, x
#         res = 0

#         while l <= r:
#             m = l + (r - l) // 2
#             if m * m > x:
#                 r = m - 1
#             elif m * m < x:
#                 l = m + 1
#                 res = m
#             else:
#                 return m

#         return res"
,Capacity to Ship Packages Within D Days,Medium,Binary Search,"Capacity To Ship Packages Within D Days
Solved
Medium
Topics
premium lock icon
Companies
Hint
A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

 

Example 1:

Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
Example 2:

Input: weights = [3,2,2,4,1,4], days = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
Example 3:

Input: weights = [1,2,3,1,1], days = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
 

Constraints:

1 <= days <= weights.length <= 5 * 104
1 <= weights[i] <= 500","class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        left = max(weights)
        right = sum(weights)

        def canShip(capacity, days):
            count = 1
            total_weight = 0
            for item in weights:
                if total_weight + item <= capacity:
                    total_weight += item
                else:
                    total_weight = item
                    count += 1
            return count <= days


        while left < right:
            mid = left + (right - left)//2

            if canShip(mid, days):
                right = mid
            else:
                left = mid + 1
            
        return left"
,Search in Rotated Sorted Array II,Medium,Binary Search,"Search in Rotated Sorted Array II
Solved
Medium
Topics
premium lock icon
Companies
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).

Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].

Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.

You must decrease the overall operation steps as much as possible.

 

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
 

Constraints:

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
nums is guaranteed to be rotated at some pivot.
-104 <= target <= 104
 

Follow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?","class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if len(nums) == 1:
            if nums[0] == target:
                return True
            else: False

        left = 0
        right = len(nums)-1

        while left <= right:
            mid = left + (right - left)//2
            mid_val = nums[mid]

            if mid_val == target:
                return True

            if nums[left] < nums[mid]:  # Left portion
                if nums[left] <= target and target < nums[mid]:
                    right = mid
                else:
                    left = mid + 1
            elif nums[left] > nums[mid]:  # Right portion
                if nums[mid] < target and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid
            else:
                left += 1        
        return False
        "
,Reverse Linked List II,Medium,Linked List,"Reverse Linked List II
Solved
Medium
Topics
premium lock icon
Companies
Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]
Example 2:

Input: head = [5], left = 1, right = 1
Output: [5]
 

Constraints:

The number of nodes in the list is n.
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n
 

Follow up: Could you do it in one pass?","# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# class Solution:
#     def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
#         dummy = ListNode()
#         dummy.next = head
#         curr = head
#         prev = dummy

#         for i in range(left-1):
#             prev = curr
#             curr = curr.next
        

#         for _ in range(right - left):
#             next_node = curr.next
#             curr.next = prev
#             prev = curr
#             curr = next_node

#             nex = curr.next
#             curr.next  = nex.next
#             nex.next = prev.next
#             prev.next = nex
            
        
#         return dummy.next




class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        curr = head
        prev = dummy

        for i in range(left-1):
            prev = curr
            curr = curr.next
        
        print(f""prev: {prev}, \ncurr: {curr}\n\n"")

        #reverse
        l_prev = None
        tmp = curr
        for i in range(right-left+1):
            nex = curr.next
            curr.next = l_prev
            l_prev = curr
            curr = nex
        
        print(f""l_prev: {l_prev}, \ncurr: {curr}\n\n"")

        prev.next = l_prev
        tmp.next = curr

        return dummy.next
        "
,Design Circular Queue,Medium,Linked List,,